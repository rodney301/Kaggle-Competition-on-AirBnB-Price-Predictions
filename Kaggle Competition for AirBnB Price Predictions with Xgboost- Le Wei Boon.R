#R code for APAN 5200 earlier attempts for Kaggle Competition by Le Wei Boon

library(corrplot)
library(dplyr)
library(stats)
library(leaps)
library(glmnet)
library(caret)
library(MASS)
library(gbm)
library(readr)
library(xgboost)



#read data and construct a simple model
data = read.csv("analysisData.csv")

#read scoring/ testing data 
scoringData = read.csv("scoringData.csv")

#setting random seed for sampling
set.seed(1031)

#setting the split ratio with stratified sampling based on "price" as the response using createDataPartition()
split <- createDataPartition(data$price, p =0.8, list = F)

#forming the training and testing data subset from "data"
train_data <- data[split,]
test_data <- data[-split,]

train_data$zipcode <- as.numeric(train_data$zipcode)
test_data$zipcode <- as.numeric(test_data$zipcode)

#trying with a smaller selected subset of variables. Excluding variables like comments, descriptions of properties, etc.
#also excluding "square_feet" as there are too many entries in the training data and scoringData with NA values for this variable
train_data_truncated <- train_data[, c(1, 19, 28, 29, 32, 38:45, 52:61, 64:69, 72:78, 84, 91, 47)]

#remove rows with NA values
train_data_cleaned <- na.omit(train_data_truncated)


#forming the correlation matrix using cor(). I have removed all non-numeric variables from the data frame so that correlation can be computed
correlationMatrix <- cor(train_data_cleaned[, c(-(1:4),-6,-7,-12, - 13, -37)])

#extracting out the correlation coefficients for variables against "price"
correlation_with_price <- correlationMatrix[,"price"]
correlation_with_price

#creating the correlation matrix viz plot with "square"
corrplot(correlationMatrix,method = 'square',type = 'lower',diag = F)

#alternative correlation matrix viz plot with "values"
corrplot(correlationMatrix,method = 'number',type = 'lower',diag = F)


#further cutting down the num of predictors after initial correlation analysis
#removing excessive variables 
train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(9:11), -(16:21), -23, -24, -(29:32), -34)]
train_data_cleaned_2


#Initial Features Selection

#Model 1: Forward subset selection 

train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(11:13), -(18:23))]

#generating another subset from training data with "price" included
train_data_cleaned_predictors_price <- train_data_cleaned_2[,c(2:29)]

#for forward selection
start_mod <- lm(price ~ 1, data = train_data_cleaned_predictors_price)
empty_mod <- lm(price ~ 1, data = train_data_cleaned_predictors_price)
full_mod <- lm(price ~ ., data = train_data_cleaned_predictors_price)

forwardstepwise <- step(start_mod, 
                        scope = list(upper = full_mod, lower = empty_mod), 
                        direction = "forward")
summary(forwardstepwise)
forwardstepwise


#Model 2: Hybrid subset selection
train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(11:13), -(18:23))]

#generating another subset from training data with "price" included
train_data_cleaned_predictors_price <- train_data_cleaned_2[,c(2:29)]


#for hybrid selection, 
start_mod <- lm(price ~ 1, data = train_data_cleaned_predictors_price)
empty_mod <- lm(price ~ 1, data = train_data_cleaned_predictors_price)
full_mod <- lm(price ~ ., data = train_data_cleaned_predictors_price)

hybridstepwise <- step(start_mod, 
                        scope = list(upper = full_mod, lower = empty_mod), 
                        direction = "both")
summary(hybridstepwise)
hybridstepwise


#Method 3: Lasso

train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(11:13), -(18:23))]

#generating another subset from training data with "price" included
train_data_cleaned_predictors_price <- train_data_cleaned_2[,c(2:29)]

#need to set seed as cross validation (i.e. cv) is random
set.seed(1031)

#forming the x (i.e. predictors) and y(i.e. the response). The price ~.1 is to exclude the intercept
x = model.matrix(price~.-1,data=train_data_cleaned_predictors_price)
y = train_data_cleaned_predictors_price$price

#set alpha = 1 for lasso. alpha = 0 for ridge
lasso_train <- cv.glmnet(x, y, nfolds = 10, alpha = 1)

lasso_train
coef(lasso_train)

#now train with the variables identified by lasso
#omitted property_type as test_data does not have it
lm_lasso_train <- lm(price ~ neighbourhood_group_cleansed + room_type + accommodates +
                       bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_90 + availability_365 +
                       number_of_reviews + number_of_reviews_ltm + review_scores_rating + review_scores_cleanliness + review_scores_location + cancellation_policy + reviews_per_month,
                     data = train_data_cleaned_predictors_price)

summary(lm_lasso_train)

#extracting the R^2 value of this linear regression
summary(lm_lasso_train)$r.squared

#predicting prices for the test data based on the lasso regression variables
pred3 <- predict(lm_lasso_train, newdata = test_data)

rmse_ana <- sqrt(mean((pred3 - test_data$price)^2))
rmse_ana



#Method 4: Ridge

train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(11:13), -(18:23))]

#generating another subset from training data with "price" included
train_data_cleaned_predictors_price <- train_data_cleaned_2[,c(2:29)]

#need to set seed as cross validation (i.e. cv) is random
set.seed(1031)

#forming the x (i.e. predictors) and y(i.e. the response). The price ~.1 is to exclude the intercept
x = model.matrix(price~.-1,data=train_data_cleaned_predictors_price)
y = train_data_cleaned_predictors_price$price

#set alpha = 1 for lasso. alpha = 0 for ridge
ridge_train <- cv.glmnet(x, y, nfolds = 10, alpha = 0)

ridge_train
coef(ridge_train)

#now train with the variables identified by lasso
#omitted property_type as test_data does not have it
lm_ridge_train <- lm(price ~ neighbourhood_group_cleansed + room_type + accommodates +
                       bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_90 + availability_365 +
                       number_of_reviews + number_of_reviews_ltm + review_scores_rating + review_scores_cleanliness + review_scores_location + cancellation_policy + reviews_per_month,
                     data = train_data_cleaned_predictors_price)

summary(lm_ridge_train)

#extracting the R^2 value of this linear regression
summary(lm_ridge_train)$r.squared

#predicting prices for the test data based on the ridge regression variables
pred3 <- predict(lm_ridge_train, newdata = test_data)

rmse_ana <- sqrt(mean((pred3 - test_data$price)^2))
rmse_ana


#Method 5: Principle Components Analysis (PCA) 
train_data_cleaned_2 <- train_data_cleaned [, c(-2, -(11:13), -(18:23))]

#generating another subset from training data with "price" included
train_data_cleaned_predictors_price <- train_data_cleaned_2[,c(2:29)]

#firstly, select the variables in test data to be the same as train_data_cleaned_predictors_price
test_data_cleaned_predictors_price = test_data[, c(28, 29, 32, 38:43, 52:55, 64:67, 68:78, 84, 91, 47)]

#performing PCA to transform the original predictors into new components (i.e. PC1, PC2,...)
#the threshold is set to 0.9. Meaning that we will select the new components PC1, PC2.... up to the component that gives us 90% of total original data variance.

trainPredictors = train_data_cleaned_predictors_price[, -28]
testPredictors = test_data_cleaned_predictors_price[, -28]

x = preProcess(x = trainPredictors,method = 'pca',thresh = 0.9)
trainComponents = predict(x,newdata=trainPredictors)

#remove property_type from trainComponents
trainComponents = trainComponents[, -3]
#add in price to trainComponents
trainComponents$price = train_data_cleaned_predictors_price$price

#using summary() to show the values of the different components. As shown, there are 7 new components (i.e. PC1 to PC7)
summary(trainComponents)

#printing out x will show "PCA needed 13 components to capture 90 percent of the variance"
x

#Finding R^2 value for a linear regression using the components found via PCA in qns 8.
model_train_pca <- lm(price ~., data = trainComponents)
summary(model_train_pca)

#extracting the R^2 value
summary(model_train_pca)$r.squared








#Final code section

#building an initial model to predict prices of rows in scoringData with property type that are not in the current list of training data
model3 <- lm(price ~ neighbourhood_group_cleansed + room_type + accommodates +
               bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month,
             data = data)

summary(model3)


#create a new small dataset comprising 1 x "Castle" and 1 x "Dome House" observations from the scoringData
#Training it with model3. Then add the price col in. Before merging these 2 observations (rows)
#back to the original "data" (i.e. analysisData). 
#Intent is to be able to use the "property_type" as a predictor in a new model. 

#creating a small dataframe by filtering rows that belong to these two property_types for the original scoringData
castle_dome_house <- scoringData %>%
  filter (property_type == "Castle" | property_type == "Dome house")

#using the earlier prediction model3 to predict the prices for these homes
pred_castle_dome_house <- predict(model3, newdata = castle_dome_house)
pred_castle_dome_house

#adding the predicted prices for these two property types back to the small dataframe
castle_dome_house$price = pred_castle_dome_house
castle_dome_house

#rearranging the columns of this very small dataframe to align with "data" (i.e. training data)
castle_dome_house_rearranged <- castle_dome_house[, c(1:46, 91, 47:90)]
castle_dome_house_rearranged

#coercing "zipcode" in the very small subset to char to align with "data" before binding by rows
castle_dome_house_rearranged$zipcode <- as.character(castle_dome_house_rearranged$zipcode)

#adding this very small dataframe to the original "data" to create a new dataset called "data_added_property_type"
data_added_property_type <- bind_rows(data, castle_dome_house_rearranged)
data_added_property_type



#Now with the training dataset pre-processed, we will explore the price distribution

#Part 1: plotting the distribution of prices based on room_type
ggplot(data_added_property_type, aes(x = room_type, y = price)) +
  geom_boxplot()

#Part 2: plotting the distribution of prices based on neighbourhood_group_cleansed
ggplot(data_added_property_type, aes(x = neighbourhood_group_cleansed, y = price)) +
  geom_boxplot()

#Plot 3: plotting the distribution of prices based on neighbourhood_group_cleansed and faceted by room_type
ggplot(data_added_property_type, aes(x = neighbourhood_group_cleansed, y = price)) +
  geom_boxplot()+
  facet_grid(vars(room_type))

#Plot 4: plotting a bar chart grouped by room_type and filled by neighbourhood_grouP-cleansed
ggplot(data=data_added_property_type,aes(y=price,x=room_type,fill=factor(neighbourhood_group_cleansed)))+ 
  geom_bar(stat="summary",fun="mean",position="dodge")









#Submission #1 on 21 Oct - RMSE of 73.19430
#based on Forward, Hybrid and Lasso regression which are currently 
#giving us the same RSME of 78.37314 (without property_type) and predictors.
#added back property_type as it is a significant predictor
#note that since we have decided on the predictors, I am rebuilding the model back from the entire dataset
lm_model_sub1 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates +
                       bathrooms + guests_included + extra_people + minimum_nights + availability_365 +
                       number_of_reviews + review_scores_rating + cancellation_policy + reviews_per_month,
                     data = data)

summary(lm_model_sub1)

#generating prediction of prices for the scoring data
pred = predict(lm_model_sub1, newdata = scoringData)
pred

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred)
write.csv(submissionFile, 'submission_1_le_wei_boon.csv', row.names = F)






#Submission #2 on 21 Oct - RMSE of 122.07382
#using PCA together with keeping property_type since it is a significant predictor

#firstly, select all the variables from entire analysisdaya
data_truncated <- data[, c(1, 19, 29, 38:45, 52:61, 64:69, 72:78, 84, 91, 47)]
data_cleaned <- na.omit(data_truncated)
data_cleaned_2 <- data_cleaned[, c(-(8:9),-(16:21), -(22:24), -27, -(29:34))]
data_cleaned_predictors_price <- data_cleaned_2[,c(2:8,10:19)]



#select the variables in test data to be the same as train_data_cleaned_predictors_price
scoring_data_cleaned_predictors = scoringData[, c(19, 29, 38:41, 44, 51:54, 66, 67, 71, 83, 90)]


#performing PCA to transform the original predictors into new components (i.e. PC1, PC2,...)
#the threshold is set to 0.9. Meaning that we will select the new components PC1, PC2.... up to the component that gives us 90% of total original data variance.

trainPredictors = data_cleaned_predictors_price[, -17]
testPredictors = scoring_data_cleaned_predictors

x = preProcess(x = trainPredictors,method = 'pca',thresh = 0.9)
trainComponents = predict(x,newdata=trainPredictors)

#remove host_is_superhost and bed_type from trainComponents since they are not significant predictors
#remove property_type as there seems to be Castle and Dome House in scoringData but not in the analysisData
trainComponents = trainComponents[, c(-1, -3, -5)]
#add in price to trainComponents
trainComponents$price = data_cleaned_predictors_price$price

#using summary() to show the values of the different components. As shown, there are 8 new components (i.e. PC1 to PC7)
summary(trainComponents)

#printing out x will show "PCA needed 8 components to capture 90 percent of the variance"
x

#Finding R^2 value for a linear regression using the components found via PCA in qns 8.
model_train_pca <- lm(price ~., data = trainComponents)
summary(model_train_pca)

#extracting the R^2 value
summary(model_train_pca)$r.squared


#finding R^2 in the test sample based on the linear regression using the PCA-transformed components
testComponents = predict(x,newdata=testPredictors)

#remove host_is_superhost and bed_type from trainComponents since they are not significant predictors
#remove property_type as there seems to be Castle and Dome House in scoringData but not in the analysisData
testComponents = testComponents[, c(-1, -3, -5)]


#generating prediction of prices for the scoring data
testPredictedprice <- predict(model_train_pca, newdata = testComponents)
testPredictedprice

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = testPredictedprice)
write.csv(submissionFile, 'submission_2_le_wei_boon.csv', row.names = F)




#Submission 3 on 21 Oct - RMSE of 71.09749
#this was chosen with the additional bedrooms, availability_30 and review_scores_location after increasing the num of predictors. Also number_of_reviews has been swapped with number_of_reviews_ltm
#based on the correlation plot via the earlier code: corrplot(correlationMatrix,method = 'number',type = 'lower',diag = F)
model3 <- lm(price ~ neighbourhood_group_cleansed + room_type + accommodates +
                  bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                  number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month,
                data = data)

summary(model3)

#generating prediction of prices for the scoring data
pred = predict(model3, newdata = scoringData)
pred

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred)
write.csv(submissionFile, 'submission_3_le_wei_boon.csv', row.names = F)




#Submission 4 on 22 Oct 
#using scaled numeric variables with the same predictors as for submission 3
#standardizing the numerical variables for "training "data" that we want so far with the best results (i.e. under Submission #3)
scaled_aaa  <- data %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", 
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_aaa


#standardizing the numerical variables for testing data
scaled_bbb  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", 
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_bbb

#using back the same predictors as Submission #3
model4 <- lm(price ~ neighbourhood_group_cleansed + room_type + accommodates +
               bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month,
             data = scaled_aaa)

summary(model4)

#predicting prices for the test data
pred1 <- predict(model4, newdata = scaled_bbb)
pred1

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred1)
write.csv(submissionFile, 'submission_4_le_wei_boon.csv', row.names = F)



#Submission 5 on 22 Oct
#create a new small dataset comprising 1 x "Castle" and 1 x "Dome House" observations from the scoringData
#I am going to train it with the model in Submission 3. Then add the price col in. Before merging back these 2 observations (rows)
#back to the original "data" (i.e. analysisData). Then train the model again with these 2 additional rows.
#Intent is to be able to use the "property_type" as a perdictor in a new model. 
#I was unable to use "property_type" as a predictor earlier as the original "data" does not include these types
#Hence, the model in submission 3 could not be used in "scoringData" as it has never seen "Castle" or "Dome House" types before. 

#creating a very small dataframe with rows that belong to these two property_types
castle_dome_house <- scoringData %>%
  filter (property_type == "Castle" | property_type == "Dome house")

#using the earlier prediction model (less "property_type") to predict the prices for these homes
pred_castle_dome_house <- predict(model3, newdata = castle_dome_house)
pred_castle_dome_house

#adding the predicted prices for these two property types back to the very small  dataframe
castle_dome_house$price = pred_castle_dome_house
castle_dome_house

#rearranging the columns of this very small dataframe to align with "data"
castle_dome_house_rearranged <- castle_dome_house[, c(1:46, 91, 47:90)]
castle_dome_house_rearranged

#coercing "zipcode" in the very small subset to char to align with "data" before binding by rows
castle_dome_house_rearranged$zipcode <- as.character(castle_dome_house_rearranged$zipcode)

#adding this very small dataframe to the origina "data" to create a new dataset called "data_added_property_type"
data_added_property_type <- bind_rows(data, castle_dome_house_rearranged)
data_added_property_type

#now, train the model with the additional predictor "property_type".
model4 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates +
               bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month,
             data = data_added_property_type)

summary(model4)

#generating prediction of prices for the scoring data
pred = predict(model4, newdata = scoringData)
pred

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred)
write.csv(submissionFile, 'submission_5_le_wei_boon.csv', row.names = F)



#Submission 6 on 22 Oct
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", 
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", 
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

#using back the same predictors as Submission #5 which has the additional "property_type"
model6 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates +
               bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month,
             data = scaled_data_added_property_type)

summary(model6)

#predicting prices for the test data
pred6 <- predict(model6, newdata = scaled_scoringData)
pred6

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred6)
write.csv(submissionFile, 'submission_6_le_wei_boon.csv', row.names = F)





#Submission 7 on 23 Oct! Tried with interaction terms!!!
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type



#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

#using interaction terms
model7 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month,
             data = scaled_data_added_property_type)

summary(model7)


#predicting prices for the test data
pred7 <- predict(model7, newdata = scaled_scoringData)
pred7

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred7)
write.csv(submissionFile, 'submission_7_le_wei_boon.csv', row.names = F)



#Submission #8 based on tree and CV

scaled_data_added_property_type_factor <- scaled_data_added_property_type

scaled_data_added_property_type_factor$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type_factor$neighbourhood_group_cleansed)
scaled_data_added_property_type_factor$room_type <- as.factor(scaled_data_added_property_type_factor$room_type)
scaled_data_added_property_type_factor$property_type <- as.factor(scaled_data_added_property_type_factor$property_type)

scaled_data_added_property_type_factor_predictor <- scaled_data_added_property_type_factor[, c(29, 38:42, 52:54, 64, 67, 69, 72, 77, 91)]
scaled_data_added_property_type_factor_response <- scaled_data_added_property_type_factor[, 47]

scaled_data_added_property_type_factor_predictor_response <- cbind(scaled_data_added_property_type_factor_predictor, scaled_data_added_property_type_factor_response)

scaled_data_added_property_type_factor_predictor_response <- scaled_data_added_property_type_factor_predictor_response %>%
  mutate(price = scaled_data_added_property_type_factor_response)

scaled_data_added_property_type_factor_predictor_response <- scaled_data_added_property_type_factor_predictor_response[, -16]

#RMSE of 75.142
model8 <- gbm.fit(x = scaled_data_added_property_type_factor_predictor,
                  y = scaled_data_added_property_type_factor_response,
             distribution = "gaussian",
             n.trees = 10000)

pred3 <- predict(model8, newdata = scaled_data_added_property_type_factor_predictor)

rmse_ana <- sqrt(mean((pred3 - scaled_data_added_property_type_factor$price)^2))
rmse_ana

summary(model8)

#predicting prices for the test data
pred8 <- predict(model8, newdata = scaled_scoringData)
pred8

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred9)
write.csv(submissionFile, 'submission_9_le_wei_boon.csv', row.names = F)



#Submission 10 based on GBM wiht 10000 trees and cv = 5
#model10 with gbm and cv
model9 <- gbm(formula = price ~ .,
             distribution = "gaussian",
             data = scaled_data_added_property_type_factor_predictor_response,
             n.trees = 10000,
             interaction.depth = 1,
             shrinkage = 0.001,
             cv.folds = 5, 
             n.cores = NULL, # will use all cores by default
             verbose = FALSE)

pred9_test <- predict(model9, newdata = scaled_data_added_property_type_factor_predictor_response)

rmse_ana <- sqrt(mean((pred9_test - scaled_data_added_property_type_factor$price)^2))
rmse_ana

summary(model9)

#predicting prices for the test data
pred9 <- predict(model9, newdata = scaled_scoringData)
pred9

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred9)
write.csv(submissionFile, 'submission_10_le_wei_boon.csv', row.names = F)




#Submission 10 based on interaction terms with additonal 2 predictors "review_scores_checkin", "review_scores_communication"


#using interaction terms
model10 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
                bathrooms * bedrooms + guests_included * extra_people + minimum_nights * maximum_minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm * reviews_per_month + review_scores_rating * review_scores_location + cancellation_policy,
              data = scaled_data_added_property_type)

summary(model10)


#predicting prices for the test data
pred10 <- predict(model10, newdata = scaled_scoringData)
pred10

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred10)
write.csv(submissionFile, 'submission_10_le_wei_boon.csv', row.names = F)



#Submission 11 based on PCA
#performing PCA to transform the original predictors into new components (i.e. PC1, PC2,...)
#the threshold is set to 0.9. Meaning that we will select the new components PC1, PC2.... up to the component that gives us 90% of total original data variance.

trainPredictors = scaled_data_added_property_type_factor_predictor

testPredictors = scaled_scoringData[, c(29, 38:42, 51:53, 63, 66, 68, 71, 76, 90)]




x = preProcess(x = trainPredictors,method = 'pca',thresh = 0.9)
trainComponents = predict(x,newdata=trainPredictors)
trainComponents$price = scaled_data_added_property_type_factor_response

#using summary() to show the values of the different components. As shown, there are 8 new components (i.e. PC1 to PC7)
summary(trainComponents)

#printing out x will show "PCA needed 9 components to capture 90 percent of the variance"
x
#Finding R^2 value for a linear regression using the components found via PCA in qns 8.
model_train_pca <- lm(price ~., data = trainComponents)
summary(model_train_pca)

#extracting the R^2 value
summary(model_train_pca)$r.squared


#finding R^2 in the test sample based on the linear regression using the PCA-transformed components
testComponents = predict(x,newdata=testPredictors)

#generating prediction of prices for the scoring data
testPredictedprice <- predict(model_train_pca, newdata = testComponents)
testPredictedprice

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = testPredictedprice)
write.csv(submissionFile, 'submission_11_le_wei_boon.csv', row.names = F)


#Submission 12 for 25 Oct

#removing the observations with price less than $20 and above $900
scaled_data_added_property_type_removed_outliers <- scaled_data_added_property_type %>%
  filter (price > 12 & price < 400)
scaled_data_added_property_type_removed_outliers

model12 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_checkin + reviews_per_month + cancellation_policy,
              data = scaled_data_added_property_type_removed_outliers)

summary(model12)

#predicting prices for the test data
pred12 <- predict(model12, newdata = scaled_scoringData)
pred12

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred12)
write.csv(submissionFile, 'submission_12_le_wei_boon.csv', row.names = F)


#Submission 13: removing outliers in each category of room_type 
#(i.e. removing the top 10% and bottom 10% of prices for each room_type)

#removing those prices that are shown to be 0
scaled_data_added_property_type_removed_0 <- scaled_data_added_property_type %>%
  filter(price != 0)

#summarising the mean and SD of price for each category of room_type
mean_sd <- scaled_data_added_property_type_removed_0 %>%
  group_by(room_type) %>%
  summarise(mean = mean(price), sd = sd(price))

mean_sd

#finding the price tagged to lowest and highest percentiles for each category of room_type
#finding the price tagged to lowest and highest percentiles for "Entire home/apt"
scaled_data_added_property_type_removed_0_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Entire home/apt")
lowest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.1)) 
highest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.9)) 
lowest_out_entirehome
highest_out_entirehome

#finding the price tagged to lowest and highest percentiles for "Private room"
scaled_data_added_property_type_removed_0_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Private room")
lowest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.1)) 
highest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.9)) 

#finding the price tagged to lowest and highest percentiles for "Shared room"
scaled_data_added_property_type_removed_0_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Shared room")
lowest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.1)) 
highest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.9)) 

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type_removed_0_out_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price >lowest_out_entirehome & price < highest_out_entirehome)
min(scaled_data_added_property_type_removed_0_out_entirehome$price)
max(scaled_data_added_property_type_removed_0_out_entirehome$price)

#putting back "Hotel room" room_type as the two entries were removed due to the filtering
scaled_data_added_property_type_removed_0_out_hotel <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Hotel room")

#removing the lowest and highest percentiles of price for "Private room"
scaled_data_added_property_type_removed_0_out_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Private room") %>%
  filter(price >lowest_out_privateroom & price < highest_out_privateroom)
min(scaled_data_added_property_type_removed_0_out_privateroom$price)
max(scaled_data_added_property_type_removed_0_out_privateroom$price)

#removing the lowest and highest percentiles of price for "Shared room"
scaled_data_added_property_type_removed_0_out_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Shared room") %>%
  filter(price >lowest_out_sharedroom & price < highest_out_sharedroom)
min(scaled_data_added_property_type_removed_0_out_sharedroom$price)
max(scaled_data_added_property_type_removed_0_out_sharedroom$price)

#filtering out the property_type of "Tent" so that these can be combined back into the overall filtered data
#with removal of outliers (i.e. those very low and high prices for each room_type)
scaled_data_added_property_type_removed_0_tent <- scaled_data_added_property_type_removed_0 %>%
  filter(property_type == "Tent")

#combining all the filtered data back to training dataset (i.e. removal of very low and high prices for each room_type)
scaled_data_combined <- rbind(scaled_data_added_property_type_removed_0_out_entirehome, scaled_data_added_property_type_removed_0_out_hotel,
                              scaled_data_added_property_type_removed_0_out_privateroom, scaled_data_added_property_type_removed_0_out_sharedroom,
                              scaled_data_added_property_type_removed_0_tent)

#training model
model13 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_checkin + reviews_per_month + cancellation_policy,
              data = scaled_data_combined)

summary(model13)

#predicting prices for the test data
pred13 <- predict(model13, newdata = scaled_scoringData)
pred13


#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred13)
write.csv(submissionFile, 'submission_13_le_wei_boon.csv', row.names = F)



#Submission 14: removing outliers in each category of room_type 
#(i.e. removing the top 5% and bottom 5% of prices for each room_type)

#removing those prices that are shown to be 0
scaled_data_added_property_type_removed_0 <- scaled_data_added_property_type %>%
  filter(price != 0)

#summarising the mean and SD of price for each category of room_type
mean_sd <- scaled_data_added_property_type_removed_0 %>%
  group_by(room_type) %>%
  summarise(mean = mean(price), sd = sd(price))

mean_sd

#finding the price tagged to lowest and highest percentiles for each category of room_type
#finding the price tagged to lowest and highest percentiles for "Entire home/apt"
scaled_data_added_property_type_removed_0_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Entire home/apt")
lowest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.05)) 
highest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.95)) 
lowest_out_entirehome
highest_out_entirehome

#finding the price tagged to lowest and highest percentiles for "Private room"
scaled_data_added_property_type_removed_0_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Private room")
lowest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.05)) 
highest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.95)) 

#finding the price tagged to lowest and highest percentiles for "Shared room"
scaled_data_added_property_type_removed_0_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Shared room")
lowest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.05)) 
highest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.95)) 

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type_removed_0_out_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price >lowest_out_entirehome & price < highest_out_entirehome)
min(scaled_data_added_property_type_removed_0_out_entirehome$price)
max(scaled_data_added_property_type_removed_0_out_entirehome$price)

#putting back "Hotel room" room_type as the two entries were removed due to the filtering
scaled_data_added_property_type_removed_0_out_hotel <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Hotel room")

#removing the lowest and highest percentiles of price for "Private room"
scaled_data_added_property_type_removed_0_out_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Private room") %>%
  filter(price >lowest_out_privateroom & price < highest_out_privateroom)
min(scaled_data_added_property_type_removed_0_out_privateroom$price)
max(scaled_data_added_property_type_removed_0_out_privateroom$price)

#removing the lowest and highest percentiles of price for "Shared room"
scaled_data_added_property_type_removed_0_out_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Shared room") %>%
  filter(price >lowest_out_sharedroom & price < highest_out_sharedroom)
min(scaled_data_added_property_type_removed_0_out_sharedroom$price)
max(scaled_data_added_property_type_removed_0_out_sharedroom$price)

#filtering out the property_type of "Tent" so that these can be combined back into the overall filtered data
#with removal of outliers (i.e. those very low and high prices for each room_type)
scaled_data_added_property_type_removed_0_tent <- scaled_data_added_property_type_removed_0 %>%
  filter(property_type == "Tent")

#combining all the filtered data back to training dataset (i.e. removal of very low and high prices for each room_type)
scaled_data_combined <- rbind(scaled_data_added_property_type_removed_0_out_entirehome, scaled_data_added_property_type_removed_0_out_hotel,
                              scaled_data_added_property_type_removed_0_out_privateroom, scaled_data_added_property_type_removed_0_out_sharedroom,
                              scaled_data_added_property_type_removed_0_tent)

#training model
model14 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_checkin + reviews_per_month + cancellation_policy,
              data = scaled_data_combined)

summary(model14)

#predicting prices for the test data
pred14 <- predict(model14, newdata = scaled_scoringData)
pred14


#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred14)
write.csv(submissionFile, 'submission_14_le_wei_boon.csv', row.names = F)





#Submission 15: removing outliers in each category of room_type 
#(i.e. removing bottom 5% and top 1% for entire home; bottom 3% and top 2% for private and shared rooms)

#removing those prices that are shown to be 0
scaled_data_added_property_type_removed_0 <- scaled_data_added_property_type %>%
  filter(price != 0)

#summarising the mean and SD of price for each category of room_type
mean_sd <- scaled_data_added_property_type_removed_0 %>%
  group_by(room_type) %>%
  summarise(mean = mean(price), sd = sd(price))

mean_sd

#finding the price tagged to lowest and highest percentiles for each category of room_type
#finding the price tagged to lowest and highest percentiles for "Entire home/apt"
scaled_data_added_property_type_removed_0_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Entire home/apt")
lowest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.05)) 
highest_out_entirehome <- quantile(scaled_data_added_property_type_removed_0_entirehome$price, c(0.99)) 
lowest_out_entirehome
highest_out_entirehome

#finding the price tagged to lowest and highest percentiles for "Private room"
scaled_data_added_property_type_removed_0_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Private room")
lowest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.03)) 
highest_out_privateroom <- quantile(scaled_data_added_property_type_removed_0_privateroom$price, c(0.98)) 

#finding the price tagged to lowest and highest percentiles for "Shared room"
scaled_data_added_property_type_removed_0_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter (room_type == "Shared room")
lowest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.03)) 
highest_out_sharedroom <- quantile(scaled_data_added_property_type_removed_0_sharedroom$price, c(0.98)) 

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type_removed_0_out_entirehome <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price >lowest_out_entirehome & price < highest_out_entirehome)
min(scaled_data_added_property_type_removed_0_out_entirehome$price)
max(scaled_data_added_property_type_removed_0_out_entirehome$price)

#putting back "Hotel room" room_type as the two entries were removed due to the filtering
scaled_data_added_property_type_removed_0_out_hotel <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Hotel room")

#removing the lowest and highest percentiles of price for "Private room"
scaled_data_added_property_type_removed_0_out_privateroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Private room") %>%
  filter(price >lowest_out_privateroom & price < highest_out_privateroom)
min(scaled_data_added_property_type_removed_0_out_privateroom$price)
max(scaled_data_added_property_type_removed_0_out_privateroom$price)

#removing the lowest and highest percentiles of price for "Shared room"
scaled_data_added_property_type_removed_0_out_sharedroom <- scaled_data_added_property_type_removed_0 %>%
  filter(room_type == "Shared room") %>%
  filter(price >lowest_out_sharedroom & price < highest_out_sharedroom)
min(scaled_data_added_property_type_removed_0_out_sharedroom$price)
max(scaled_data_added_property_type_removed_0_out_sharedroom$price)

#filtering out the property_type of "Tent" so that these can be combined back into the overall filtered data
#with removal of outliers (i.e. those very low and high prices for each room_type)
scaled_data_added_property_type_removed_0_tent <- scaled_data_added_property_type_removed_0 %>%
  filter(property_type == "Tent")

#combining all the filtered data back to training dataset (i.e. removal of very low and high prices for each room_type)
scaled_data_combined <- rbind(scaled_data_added_property_type_removed_0_out_entirehome, scaled_data_added_property_type_removed_0_out_hotel,
                              scaled_data_added_property_type_removed_0_out_privateroom, scaled_data_added_property_type_removed_0_out_sharedroom,
                              scaled_data_added_property_type_removed_0_tent)

#training model
model15 <- lm(price ~ neighbourhood_group_cleansed + room_type + property_type + accommodates *
                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_checkin + reviews_per_month + cancellation_policy,
              data = scaled_data_combined)

summary(model15)

#predicting prices for the test data
pred15 <- predict(model15, newdata = scaled_scoringData)
pred15


#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred15)
write.csv(submissionFile, 'submission_15_le_wei_boon.csv', row.names = F)



#Submission 16 based on GBM wiht 10000 trees and cv = 5
#model10 with gbm and cv


scaled_data_combined_factor <- scaled_data_combined

scaled_data_combined_factor$neighbourhood_group_cleansed <- as.factor(scaled_data_combined_factor$neighbourhood_group_cleansed)
scaled_data_combined_factor$room_type <- as.factor(scaled_data_combined_factor$room_type)
scaled_data_combined_factor$property_type <- as.factor(scaled_data_combined_factor$property_type)

scaled_data_combined_factor_predictor <- scaled_data_combined_factor[, c(29, 38:42, 52:54, 64, 67, 69, 72, 77, 91)]
scaled_data_combined_factor_response <- scaled_data_combined_factor[, 47]

scaled_data_combined_factor_predictor_response <- cbind(scaled_data_combined_factor_predictor, scaled_data_combined_factor_response)

scaled_data_combined_factor_predictor_response <- scaled_data_combined_factor_predictor_response %>%
  mutate(price = scaled_data_combined_factor_response)

scaled_data_combined_factor_predictor_response <- scaled_data_combined_factor_predictor_response[, -16]

model16 <- gbm(formula = price ~ .,
              distribution = "tdist",
              data = scaled_data_combined_factor_predictor_response,
              n.trees = 10000,
              interaction.depth = 1,
              shrinkage = 0.001,
              cv.folds = 5, 
              n.cores = NULL, # will use all cores by default
              verbose = FALSE)

pred16_test <- predict(model16, newdata = scaled_data_combined_factor_predictor_response)

rmse_ana <- sqrt(mean((pred16_test - scaled_data_combined_factor_predictor_response$price)^2))
rmse_ana

summary(model16)

#predicting prices for the test data
pred16 <- predict(model16, newdata = scaled_scoringData)
pred16

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred16)
write.csv(submissionFile, 'submission_16_le_wei_boon.csv', row.names = F)




#Submission 17 based on GBM wiht 10000 trees and cv = 5
#model17 with gbm and cv and distribution = tdist
model17 <- gbm(formula = price ~ .,
              distribution = "tdist",
              data = scaled_data_added_property_type_factor_predictor_response,
              n.trees = 10000,
              interaction.depth = 1,
              shrinkage = 0.001,
              cv.folds = 5, 
              n.cores = NULL, # will use all cores by default
              verbose = FALSE)

pred17_test <- predict(model17, newdata = scaled_data_added_property_type_factor_predictor_response)

rmse_ana <- sqrt(mean((pred17_test - scaled_data_added_property_type_factor$price)^2))
rmse_ana

summary(model17)

#predicting prices for the test data
pred17 <- predict(model17, newdata = scaled_scoringData)
pred17

#Construct submission from prediction
submissionFile = data.frame(id = scoringData$id, price = pred17)
write.csv(submissionFile, 'submission_17_le_wei_boon.csv', row.names = F)





#Submission 18 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month,
             data = scaled_data_added_property_type_entirehome)

summary(modelentirehome)

modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month,
                      data = scaled_data_added_property_type_private)

summary(modelprivate)

modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month,
                      data = scaled_data_added_property_type_shared)

summary(modelshared)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month"),
            ~(scale(.) %>% as.vector))
scaled_scoringData



scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_18_le_wei_boon.csv', row.names = F)





#Submission 20 - lm with higher power
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                      data = scaled_data_added_property_type_entirehome)

summary(modelentirehome)

pre666 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
rmse_entire666 <- sqrt(mean((pre1-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire666


modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777


modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_20_le_wei_boon.csv', row.names = F)











#Submission 21 - removal of some outliers based on submission 20
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.002)) 
highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
lowest_price
highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price & price < highest_price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)





scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                      data = scaled_data_added_property_type_entirehome)

summary(modelentirehome)

pre1 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
rmse_entire1 <- sqrt(mean((pre1-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire1
pre1



modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)



modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)




#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_21_le_wei_boon.csv', row.names = F)





#Submission 22 - removal of some outliers based on submission 20
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.002)) 
highest_price <- quantile(scaled_data_added_property_type$price, c(0.99)) 
lowest_price
highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price & price < highest_price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)





scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                      data = scaled_data_added_property_type_entirehome)

summary(modelentirehome)

modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)




#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_22_le_wei_boon.csv', row.names = F)











#Submission 23 - removal of some outliers based on submission 20
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.002)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price & price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)



scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)



scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")
scaled_data_added_property_type_shared <- scaled_data_added_property_type_shared 

#modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
#                      data = scaled_data_added_property_type_entirehome)
#summary(modelentirehome)


modelentirehome_gbm <- gbm(formula = price ~ neighbourhood_group_cleansed + property_type + accommodates +
                bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_entire_homes + cancellation_policy,
              distribution = "gaussian",
              data = scaled_data_added_property_type_entirehome,
              n.trees = 5000,
              n.minobsinnode = 5,
              interaction.depth = 1,
              shrinkage = 0.001,
              cv.folds = 5, 
              n.cores = NULL, # will use all cores by default
              verbose = FALSE)

summary(modelentirehome_gbm)

pre <- predict(modelentirehome_gbm, newdata = scaled_data_added_property_type_entirehome)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire
pre




scaled_data_added_property_type_entirehome_predictor <- scaled_data_added_property_type_entirehome [, c(29, 38, 40:42, 52:54, 64, 67, 69, 72, 77, 91, 78, 87, 88, 84)]

scaled_data_added_property_type_entirehome_predictor$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type_entirehome_predictor$neighbourhood_group_cleansed)
scaled_data_added_property_type_entirehome_predictor$cancellation_policy <- as.factor(scaled_data_added_property_type_entirehome_predictor$cancellation_policy)
scaled_data_added_property_type_entirehome_predictor$property_type <- as.factor(scaled_data_added_property_type_entirehome_predictor$property_type)


modelentirehome_tree <- gbm.fit(x = scaled_data_added_property_type_entirehome_predictor,
                  y = scaled_data_added_property_type_entirehome$price,
                  distribution = "gaussian",
                  n.trees = 10000)

pre <- predict(modelentirehome_tree, newdata = scaled_data_added_property_type_entirehome)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire






#modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)

modelprivate_gbm <- gbm(formula = price ~ neighbourhood_group_cleansed + property_type + accommodates +
                                               bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                                               number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_private_rooms,
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_private,
                           n.trees = 5000,
                           interaction.depth = 1,
                           shrinkage = 0.001,
                           cv.folds = 5, 
                           n.cores = NULL, # will use all cores by default
                           verbose = FALSE)

summary(modelprivate_gbm)

#pre <- predict(modelprivate_gbm, newdata = scaled_data_added_property_type_private)
#rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private$price)^2))
#rmse_entire



#modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
#                  data = scaled_data_added_property_type_shared)

#summary(modelshared)


modelshared_gbm <- gbm(price ~ neighbourhood_group_cleansed + property_type + accommodates +
                          bathrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                          number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                        distribution = "gaussian",
                        data = scaled_data_added_property_type_shared,
                        n.trees = 5000,
                        interaction.depth = 1,
                        shrinkage = 0.001,
                        cv.folds = 5, 
                        n.cores = NULL, # will use all cores by default
                        verbose = FALSE)

summary(modelshared_gbm)




#pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
#rmse_entire <- sqrt(mean(pre-scaled_data_added_property_type_shared$price)^2)
#rmse_entire
#pre 


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_21_le_wei_boon.csv', row.names = F)







#Submission 24 - 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
data_added_property_type <- data_added_property_type %>%
  mutate(price_per_pax = price / accommodates)


scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 

lowest_price


#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)




#separating out entirehomes with more ppl and those will less ppl
scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_entirehome_more_ppl <- scaled_data_added_property_type_entirehome %>%
  filter(accommodates >= 4)

scaled_data_added_property_type_entirehome_less_ppl <- scaled_data_added_property_type_entirehome %>%
  filter(accommodates < 4)

#separating out hotels
scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")


#separating out private rooms with more ppl and those will less ppl
scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_private_more_ppl <- scaled_data_added_property_type_private %>%
  filter(accommodates >= 3)

scaled_data_added_property_type_private_less_ppl <- scaled_data_added_property_type_private %>%
  filter(accommodates < 3)


#separating out shared properties
scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



#Training for entirehomes
#For entirehomes with more ppl: training by price_per_pex for entire homes which can accommodate more ppl
modelentirehome_more_ppl <- lm(price_per_pax ~ neighbourhood_group_cleansed + property_type +
                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                      data = scaled_data_added_property_type_entirehome_more_ppl)

summary(modelentirehome_more_ppl)

pre1 <- predict(modelentirehome_more_ppl, newdata = scaled_data_added_property_type_entirehome_more_ppl)
scaled_data_added_property_type_entirehome_more_ppl$predicted_per_pax <- pre1

scaled_data_added_property_type_entirehome_more_ppl <- scaled_data_added_property_type_entirehome_more_ppl %>%
  mutate(predicted_total = predicted_per_pax * accommodates)

pre1_total_price <- (pre1 * scaled_data_added_property_type_entirehome_more_ppl$accommodates)
rmse_entire1 <- sqrt(mean((pre1_total_price-scaled_data_added_property_type_entirehome_more_ppl$price)^2))
rmse_entire1


#For entirehomes with lesser ppl: training by price for entire homes which can accommodate lesser ppl
modelentirehome_less_ppl <- lm(price ~ neighbourhood_group_cleansed +
                                 bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                 number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                               data = scaled_data_added_property_type_entirehome_less_ppl)

summary(modelentirehome_less_ppl)

pre2 <- predict(modelentirehome_less_ppl, newdata = scaled_data_added_property_type_entirehome_less_ppl)
rmse_entire2 <- sqrt(mean((pre2-scaled_data_added_property_type_entirehome_less_ppl$price)^2))
rmse_entire2




#Training for private rooms
#For private rooms with more ppl: training by price_per_pex for private rooms which can accommodate more ppl
modelprivate_more_ppl <- lm(price_per_pax ~ neighbourhood_group_cleansed +
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            data = scaled_data_added_property_type_private_more_ppl)

summary(modelprivate_more_ppl)

pre3 <- predict(modelprivate_more_ppl, newdata = scaled_data_added_property_type_private_more_ppl)
scaled_data_added_property_type_private_more_ppl$predicted_per_pax <- pre3

scaled_data_added_property_type_private_more_ppl <- scaled_data_added_property_type_private_more_ppl %>%
  mutate(predicted_total = predicted_per_pax * accommodates)

pre3_total_price <- (pre3 * scaled_data_added_property_type_private_more_ppl$accommodates)
rmse_entire3 <- sqrt(mean((pre3_total_price-scaled_data_added_property_type_private_more_ppl$price)^2))
rmse_entire3



#For private rooms with lesser ppl: training by price for private rooms which can accommodate lesser ppl
modelprivate_less_ppl <- lm(price ~ neighbourhood_group_cleansed + property_type +
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            data = scaled_data_added_property_type_private_less_ppl)

summary(modelprivate_less_ppl)

pre4 <- predict(modelprivate_less_ppl, newdata = scaled_data_added_property_type_private_less_ppl)
rmse_entire4 <- sqrt(mean((pre4-scaled_data_added_property_type_private_less_ppl$price)^2))
rmse_entire4



#modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)

modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)




#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

#filtering out the scoringData into entirehome with more ppl and entirehome with less ppl
scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_entirehome_more_ppl <- scaled_scoringData_entirehome %>%
  filter(accommodates >= 4)

scaled_scoringData_entirehome_less_ppl <- scaled_scoringData_entirehome %>%
  filter(accommodates < 4)

#filtering out property_type of "Cabin"
scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

#filtering out hotel
scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

#filtering out private room with more ppl and less ppl
scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_private_more_ppl <- scaled_scoringData_private %>%
  filter(accommodates >= 3)

scaled_scoringData_private_less_ppl <- scaled_scoringData_private %>%
  filter(accommodates < 3)

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome_more_ppl <- predict(modelentirehome_more_ppl, newdata = scaled_scoringData_entirehome_more_ppl)
pred_entirehome_more_ppl <- (pred_entirehome_more_ppl * scaled_scoringData_entirehome_more_ppl$accommodates)

pred_entirehome_less_ppl <- predict(modelentirehome_less_ppl, newdata = scaled_scoringData_entirehome_less_ppl)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_more_ppl <- predict(modelprivate_more_ppl, newdata = scaled_scoringData_private_more_ppl)
pred_private_more_ppl <- (pred_private_more_ppl * scaled_scoringData_private_more_ppl$accommodates)


pred_private_less_ppl <- predict(modelprivate_less_ppl, newdata = scaled_scoringData_private_less_ppl)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome_more_ppl$price <- pred_entirehome_more_ppl
scaled_scoringData_entirehome_less_ppl$price <- pred_entirehome_less_ppl
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private_more_ppl$price <- pred_private_more_ppl
scaled_scoringData_private_less_ppl$price <- pred_private_less_ppl
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_more_ppl_id_price <- scaled_scoringData_entirehome_more_ppl [, c(1,91)]
scaled_scoringData_entirehome_less_ppl_id_price <- scaled_scoringData_entirehome_less_ppl [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_more_ppl_id_price <- scaled_scoringData_private_more_ppl [, c(1,91)]
scaled_scoringData_private_less_ppl_id_price <- scaled_scoringData_private_less_ppl [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_more_ppl_id_price,
                                  scaled_scoringData_entirehome_less_ppl_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_more_ppl_id_price,
                                  scaled_scoringData_private_less_ppl_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_24_le_wei_boon.csv', row.names = F)













#Submission 25 - using a dedicated model for entirehomes and private rooms with more ppl
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
data_added_property_type <- data_added_property_type %>%
  mutate(price_per_pax = price / accommodates)


scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 

lowest_price


#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)




#separating out entirehomes with more ppl and those will less ppl
scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_entirehome_more_ppl <- scaled_data_added_property_type_entirehome %>%
  filter(accommodates >= 4)

scaled_data_added_property_type_entirehome_less_ppl <- scaled_data_added_property_type_entirehome %>%
  filter(accommodates < 4)

#separating out hotels
scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")


#separating out private rooms with more ppl and those will less ppl
scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_private_more_ppl <- scaled_data_added_property_type_private %>%
  filter(accommodates >= 2)

scaled_data_added_property_type_private_less_ppl <- scaled_data_added_property_type_private %>%
  filter(accommodates < 2)


#separating out shared properties
scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



#Training for entirehomes
#For entirehomes with more ppl: training by price for entire homes which can accommodate more ppl
modelentirehome_more_ppl <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                                 bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                 number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                               data = scaled_data_added_property_type_entirehome_more_ppl)

summary(modelentirehome_more_ppl)



pre1 <- predict(modelentirehome_more_ppl, newdata = scaled_data_added_property_type_entirehome_more_ppl)
#scaled_data_added_property_type_entirehome_more_ppl$predicted_per_pax <- pre1

#scaled_data_added_property_type_entirehome_more_ppl <- scaled_data_added_property_type_entirehome_more_ppl %>%
#  mutate(predicted_total = predicted_per_pax * accommodates)

#pre1_total_price <- (pre1 * scaled_data_added_property_type_entirehome_more_ppl$accommodates)
rmse_entire1 <- sqrt(mean((pre1-scaled_data_added_property_type_entirehome_more_ppl$price)^2))
rmse_entire1


#For entirehomes with lesser ppl: training by price for entire homes which can accommodate lesser ppl
#but I am training with the entire dataset for entirehome
modelentirehome_less_ppl <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                                 bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                 number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
                               data = scaled_data_added_property_type_entirehome)

summary(modelentirehome_less_ppl)

pre2 <- predict(modelentirehome_less_ppl, newdata = scaled_data_added_property_type_entirehome_less_ppl)
rmse_entire2 <- sqrt(mean((pre2-scaled_data_added_property_type_entirehome_less_ppl$price)^2))
rmse_entire2




#Training for private rooms
#For private rooms with more ppl: training by price_per_pex for private rooms which can accommodate more ppl
modelprivate_more_ppl <- lm(price ~ neighbourhood_group_cleansed + property_type +
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            data = scaled_data_added_property_type_private_more_ppl)

summary(modelprivate_more_ppl)

pre3 <- predict(modelprivate_more_ppl, newdata = scaled_data_added_property_type_private_more_ppl)
#scaled_data_added_property_type_private_more_ppl$predicted_per_pax <- pre3

#scaled_data_added_property_type_private_more_ppl <- scaled_data_added_property_type_private_more_ppl %>%
#  mutate(predicted_total = predicted_per_pax * accommodates)

#pre3_total_price <- (pre3 * scaled_data_added_property_type_private_more_ppl$accommodates)
rmse_entire3 <- sqrt(mean((pre3-scaled_data_added_property_type_private_more_ppl$price)^2))
rmse_entire3



#For private rooms with lesser ppl: training by price for private rooms which can accommodate lesser ppl
#but I am training with the private rooms dataset for entirehome
modelprivate_less_ppl <- lm(price ~ neighbourhood_group_cleansed + property_type +
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            data = scaled_data_added_property_type_private)

summary(modelprivate_less_ppl)

pre4 <- predict(modelprivate_less_ppl, newdata = scaled_data_added_property_type_private_less_ppl)
rmse_entire4 <- sqrt(mean((pre4-scaled_data_added_property_type_private_less_ppl$price)^2))
rmse_entire4



#modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)

modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)




#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

#filtering out the scoringData into entirehome with more ppl and entirehome with less ppl
scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_entirehome_more_ppl <- scaled_scoringData_entirehome %>%
  filter(accommodates >= 4)

scaled_scoringData_entirehome_less_ppl <- scaled_scoringData_entirehome %>%
  filter(accommodates < 4)

#filtering out property_type of "Cabin"
scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

#filtering out hotel
scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

#filtering out private room with more ppl and less ppl
scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_private_more_ppl <- scaled_scoringData_private %>%
  filter(accommodates >= 3)

scaled_scoringData_private_less_ppl <- scaled_scoringData_private %>%
  filter(accommodates < 3)

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome_more_ppl <- predict(modelentirehome_more_ppl, newdata = scaled_scoringData_entirehome_more_ppl)
pred_entirehome_less_ppl <- predict(modelentirehome_less_ppl, newdata = scaled_scoringData_entirehome_less_ppl)

pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_more_ppl <- predict(modelprivate_more_ppl, newdata = scaled_scoringData_private_more_ppl)
pred_private_less_ppl <- predict(modelprivate_less_ppl, newdata = scaled_scoringData_private_less_ppl)

pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome_more_ppl$price <- pred_entirehome_more_ppl
scaled_scoringData_entirehome_less_ppl$price <- pred_entirehome_less_ppl
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private_more_ppl$price <- pred_private_more_ppl
scaled_scoringData_private_less_ppl$price <- pred_private_less_ppl
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_more_ppl_id_price <- scaled_scoringData_entirehome_more_ppl [, c(1,91)]
scaled_scoringData_entirehome_less_ppl_id_price <- scaled_scoringData_entirehome_less_ppl [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_more_ppl_id_price <- scaled_scoringData_private_more_ppl [, c(1,91)]
scaled_scoringData_private_less_ppl_id_price <- scaled_scoringData_private_less_ppl [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_more_ppl_id_price,
                                  scaled_scoringData_entirehome_less_ppl_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_more_ppl_id_price,
                                  scaled_scoringData_private_less_ppl_id_price,
                                  scaled_scoringData_shared_id_price)

#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 20) %>%
  mutate (price = 20)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 20)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]



#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_25_le_wei_boon.csv', row.names = F)























#Submission 26 - removal of some outliers based on submission 20 and performing GBM
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#finding the price tagged to lowest and highest percentiles for homes
lowest_price <- quantile(scaled_data_added_property_type$price, c(0.002)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
scaled_data_added_property_type <- scaled_data_added_property_type %>%
  filter(price >lowest_price & price)
min(scaled_data_added_property_type$price)
max(scaled_data_added_property_type$price)



scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)



scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")
scaled_data_added_property_type_shared <- scaled_data_added_property_type_shared 

#modelentirehome <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                        bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_entire_homes + cancellation_policy,
#                      data = scaled_data_added_property_type_entirehome)
#summary(modelentirehome)

set.seed(1031)
modelentirehome_gbm <- gbm(formula = price ~ neighbourhood_group_cleansed + property_type + accommodates +
                             bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_entire_homes + cancellation_policy,
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome,
                           n.trees = 10000,
                           n.minobsinnode = 5,
                           interaction.depth = 1,
                           shrinkage = 0.001,
                           cv.folds = 5, 
                           n.cores = NULL, # will use all cores by default
                           verbose = FALSE)

summary(modelentirehome_gbm)




#set.seed(1031)
#modelentirehome_gbm <- gbm(formula = price ~ neighbourhood_group_cleansed + property_type + accommodates +
#                             bathrooms + bedrooms + extra_people + availability_30 + availability_365 +
#                             review_scores_location,                           
#                           distribution = "gaussian",
 #                          data = scaled_data_added_property_type_entirehome,
#                           n.trees = 10000,
#                           n.minobsinnode = 5,
#                           interaction.depth = 1,
#                           shrinkage = 0.001,
#                           cv.folds = 5, 
#                           n.cores = NULL, # will use all cores by default
#                           verbose = FALSE)

set.seed(1031)
pre <- predict(modelentirehome_gbm, newdata = scaled_data_added_property_type_entirehome)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire




#scaled_data_added_property_type_entirehome_predictor <- scaled_data_added_property_type_entirehome [, c(29, 38, 40:42, 52:54, 64, 67, 69, 72, 77, 91, 78, 87, 88, 84)]

#scaled_data_added_property_type_entirehome_predictor$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type_entirehome_predictor$neighbourhood_group_cleansed)
#scaled_data_added_property_type_entirehome_predictor$cancellation_policy <- as.factor(scaled_data_added_property_type_entirehome_predictor$cancellation_policy)
#scaled_data_added_property_type_entirehome_predictor$property_type <- as.factor(scaled_data_added_property_type_entirehome_predictor$property_type)


#modelentirehome_tree <- gbm.fit(x = scaled_data_added_property_type_entirehome_predictor,
#                                y = scaled_data_added_property_type_entirehome$price,
#                                distribution = "gaussian",
#                                n.trees = 10000)

#pre <- predict(modelentirehome_tree, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire






#modelprivate <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)


set.seed(1031)
modelprivate_gbm <- gbm(formula = price ~ neighbourhood_group_cleansed + property_type + accommodates +
                          bathrooms + bedrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                          number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_private_rooms,
                        distribution = "gaussian",
                        data = scaled_data_added_property_type_private,
                        n.trees = 10000,
                        interaction.depth = 1,
                        shrinkage = 0.001,
                        cv.folds = 5, 
                        n.cores = NULL, # will use all cores by default
                        verbose = FALSE)

summary(modelprivate_gbm)

set.seed(1031)
pre <- predict(modelprivate_gbm, newdata = scaled_data_added_property_type_private)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private$price)^2))
rmse_entire



#modelshared <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
#                  data = scaled_data_added_property_type_shared)

#summary(modelshared)

set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_group_cleansed + property_type + accommodates +
                         bathrooms + guests_included + extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating + review_scores_location + reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 10000,
                       interaction.depth = 1,
                       shrinkage = 0.001,
                       cv.folds = 5, 
                       n.cores = NULL, # will use all cores by default
                       verbose = FALSE)

summary(modelshared_gbm)



set.seed(1031)
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire



#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")

scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100
pred_private <- predict(modelprivate, newdata = scaled_scoringData_private)
pred_shared <- predict(modelshared, newdata = scaled_scoringData_shared)

scaled_scoringData_entirehome$price <- pred_entirehome
scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel
scaled_scoringData_private$price <- pred_private
scaled_scoringData_shared$price <- pred_shared

scaled_scoringData_entirehome_id_price <- scaled_scoringData_entirehome [, c(1,91)]
scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]
scaled_scoringData_private_id_price <- scaled_scoringData_private [, c(1,91)]
scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,91)]

scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_id_price,
                                  scaled_scoringData_shared_id_price)
scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_26_le_wei_boon.csv', row.names = F)







#Submission 27 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")




#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ zipcode + accommodates *
                        bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                          cancellation_policy,
                      data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111

#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ accommodates *
                            bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ zipcode + accommodates *
                            bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                          data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ zipcode + property_type + accommodates *
                                  bathrooms * bedrooms + minimum_nights + availability_30 +
                                  review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_out <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))



#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast")

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                               scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581)

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                                scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433)

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                        scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_27_le_wei_boon.csv', row.names = F)








































































































































































#Submission 28 - lm and with usage of zipcode and interaction of zipcode. NOT AS GOOD AS SUBMISSION 27!
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room")

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")




#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ zipcode * accommodates *
                            bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111

#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ zipcode * accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ zipcode * property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ zipcode * neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ zipcode * neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_out <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))



#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast")

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581)

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433)

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#replacing predicted price >= $999 to default $20
scaled_scoringData_price_huge <- scaled_scoringData_price %>%
  filter(price >= 999) %>%
  mutate (price = 999)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10 & price < 999)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative,
                                  scaled_scoringData_price_huge)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_28_le_wei_boon.csv', row.names = F)


























#Submission 29 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")



#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_man_predictors_price <- scaled_data_added_property_type_entirehome_man[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_man_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_man_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_man_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise




#using lm for entirehome manhattan with newly added variables from Submission #27.
modelentirehome_man <- lm(price ~ zipcode + accommodates *
                            bathrooms * bedrooms  + minimum_nights * maximum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy + calculated_host_listings_count_entire_homes,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111







#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ accommodates *
                                bathrooms * bedrooms  + minimum_nights * maximum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy + calculated_host_listings_count_entire_homes,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)






#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_brook_predictors_price <- scaled_data_added_property_type_entirehome_brook[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_brook_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_brook_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_brook_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise




#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ zipcode + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm * reviews_per_month + review_scores_rating * review_scores_location + review_scores_value + calculated_host_listings_count,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112



#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm * reviews_per_month + review_scores_rating * review_scores_location + review_scores_value + calculated_host_listings_count,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)



#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_rest_predictors_price <- scaled_data_added_property_type_entirehome_rest[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_rest_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_rest_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_rest_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113



#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114



#generating another subset from training data with "price" included
scaled_data_added_property_type_private_man_predictors_price <- scaled_data_added_property_type_private_man[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_man_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_man_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_private_man_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise


#model for private
modelprivate_man <- lm(price ~ zipcode + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms + cancellation_policy,
                   data = scaled_data_added_property_type_private_man)

summary(modelprivate_man)

pre777 <- predict(modelprivate_man, newdata = scaled_data_added_property_type_private_man)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private_man$price)^2))
rmse_entire777


#model for private (outliers that cannot match zipcode)
modelprivate_man_out <- lm(price ~  property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms + cancellation_policy,
                       data = scaled_data_added_property_type_private_man)

summary(modelprivate_man_out)




#generating another subset from training data with "price" included
scaled_data_added_property_type_private_brook_predictors_price <- scaled_data_added_property_type_private_brook[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_brook_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_brook_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_private_brook_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise


#model for private_brook
modelprivate_brook <- lm(price ~ zipcode + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value  + calculated_host_listings_count_private_rooms + cancellation_policy,
                       data = scaled_data_added_property_type_private_brook)

summary(modelprivate_brook)

pre777 <- predict(modelprivate_brook, newdata = scaled_data_added_property_type_private_brook)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire777



#model for private (outliers that cannot match zipcode)
modelprivate_brook_out <- lm(price ~ accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value + calculated_host_listings_count_private_rooms + cancellation_policy,
                             data = scaled_data_added_property_type_private_brook)

summary(modelprivate_brook_out)




#generating another subset from training data with "price" included
scaled_data_added_property_type_private_rest_predictors_price <- scaled_data_added_property_type_private_rest[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_rest_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_rest_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_private_rest_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise


#model for private_brook
modelprivate_rest <- lm(price ~ zipcode + property_type + accommodates *
                           bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                           number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value * review_scores_checkin + calculated_host_listings_count_private_rooms * calculated_host_listings_count + cancellation_policy,
                         data = scaled_data_added_property_type_private_rest)

summary(modelprivate_rest)

pre777 <- predict(modelprivate_rest, newdata = scaled_data_added_property_type_private_rest)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire777



#model for private (outliers that cannot match zipcode)
modelprivate_rest_out <- lm(price ~ accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value * review_scores_checkin + calculated_host_listings_count_private_rooms * calculated_host_listings_count + cancellation_policy,
                            data = scaled_data_added_property_type_private_rest)

summary(modelprivate_rest_out)





#using lm for shared
modelshared <- lm(price ~ zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)






#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_out <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))



#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast")

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")




#keeping the rest of data in private that are not outliers
#scaled_scoringData_private_main <- scaled_scoringData_private %>%
#  filter(id != 30838350) %>%
#  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
#scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
#scaled_scoringData_private_out <- scaled_scoringData_private %>%
#  filter(zipcode == 11581)

#scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
#                                        scaled_scoringData_private_out)




scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


scaled_scoringData_private_man_main <- scaled_scoringData_private_man %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_man_main_zipcode_na <- subset(scaled_scoringData_private_man, is.na(zipcode))
#separating out the that are outliers on postal code 
scaled_scoringData_private_man_out <- scaled_scoringData_private_man_main_zipcode_na



#splitting private into Brook 
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#removing the outliers in manhattan with property_type of Bungalow, Tiny house
scaled_scoringData_private_brook_main <- scaled_scoringData_private_brook %>%
  filter(property_type != "Bungalow") %>%
  filter(property_type != "Tiny house")%>%
  filter(zipcode != 'NA')


#pulling out rows with zipcode as NA
scaled_scoringData_private_brook_main_zipcode_na <- subset(scaled_scoringData_private_brook, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_private_brook_out <- scaled_scoringData_private_brook %>%
  filter(property_type == "Bungalow" | property_type== "Tiny house")

scaled_scoringData_private_brook_out <- rbind(scaled_scoringData_private_brook_main_zipcode_na,
                                              scaled_scoringData_private_brook_out)






#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


#removing the IDs are the two outliers in the rest with zipcodes of 
scaled_scoringData_private_rest_main <- scaled_scoringData_private_rest %>%
  filter(zipcode != 10031) %>%
  filter(zipcode != 11581) %>%
  filter(property_type != "Tent")%>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_rest_main_zipcode_na <- subset(scaled_scoringData_private_rest, is.na(zipcode))
#separating out the that are outliers on postal code in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_private_rest_out <- scaled_scoringData_private_rest %>%
  filter(zipcode == 10031 | zipcode == 11581 | property_type == "Tent")

scaled_scoringData_private_rest_out <- rbind(scaled_scoringData_private_rest_main_zipcode_na,
                                             scaled_scoringData_private_rest_out)



#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433)

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

#pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
#pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_private_man_main <- predict(modelprivate_man, newdata = scaled_scoringData_private_man_main)
pred_private_man_out <- predict(modelprivate_man_out, newdata = scaled_scoringData_private_man_out)

pred_private_brook_main <- predict(modelprivate_brook, newdata = scaled_scoringData_private_brook_main)
pred_private_brook_out <- predict(modelprivate_brook_out, newdata = scaled_scoringData_private_brook_out)

pred_private_rest_main <- predict(modelprivate_rest, newdata = scaled_scoringData_private_rest_main)
pred_private_rest_out <- predict(modelprivate_rest_out, newdata = scaled_scoringData_private_rest_out)


pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)




scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man_main$price <- pred_private_man_main
scaled_scoringData_private_man_out$price <- pred_private_man_out

scaled_scoringData_private_brook_main$price <- pred_private_brook_main
scaled_scoringData_private_brook_out$price <- pred_private_brook_out

scaled_scoringData_private_rest_main$price <- pred_private_rest_main
scaled_scoringData_private_rest_out$price <- pred_private_rest_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out



scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_man_main_id_price <- scaled_scoringData_private_man_main [, c(1,91)]
scaled_scoringData_private_man_out_id_price <- scaled_scoringData_private_man_out [, c(1,91)]

scaled_scoringData_private_brook_main_id_price <- scaled_scoringData_private_brook_main [, c(1,91)]
scaled_scoringData_private_brook_out_id_price <- scaled_scoringData_private_brook_out [, c(1,91)]

scaled_scoringData_private_rest_main_id_price <- scaled_scoringData_private_rest_main [, c(1,91)]
scaled_scoringData_private_rest_out_id_price <- scaled_scoringData_private_rest_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]




scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_main_id_price,
                                  scaled_scoringData_private_man_out_id_price,
                                  scaled_scoringData_private_brook_main_id_price,
                                  scaled_scoringData_private_brook_out_id_price,
                                  scaled_scoringData_private_rest_main_id_price,
                                  scaled_scoringData_private_rest_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)



#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#replacing predicted price >= $999 to default $20
scaled_scoringData_price_huge <- scaled_scoringData_price %>%
  filter(price >= 999) %>%
  mutate (price = 999)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10 & price < 999)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative,
                                  scaled_scoringData_price_huge)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_29_le_wei_boon.csv', row.names = F)










#Submission 30 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")




#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_man_predictors_price <- scaled_data_added_property_type_entirehome_man[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_man_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_man_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_man_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise




#using lm for entirehome manhattan with newly added variables from Submission #27.
modelentirehome_man <- lm(price ~ zipcode + accommodates *
                            bathrooms * bedrooms  + minimum_nights * maximum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy + calculated_host_listings_count_entire_homes,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111







#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ accommodates *
                                bathrooms * bedrooms  + minimum_nights * maximum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy + calculated_host_listings_count_entire_homes,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)






#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_brook_predictors_price <- scaled_data_added_property_type_entirehome_brook[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_brook_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_brook_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_brook_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise




#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ zipcode + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm * reviews_per_month + review_scores_rating * review_scores_location + review_scores_value + calculated_host_listings_count,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112



#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm * reviews_per_month + review_scores_rating * review_scores_location + review_scores_value + calculated_host_listings_count,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)



#generating another subset from training data with "price" included
scaled_data_added_property_type_entirehome_rest_predictors_price <- scaled_data_added_property_type_entirehome_rest[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_rest_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_entirehome_rest_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_entirehome_rest_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113



#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114



#generating another subset from training data with "price" included
scaled_data_added_property_type_private_man_predictors_price <- scaled_data_added_property_type_private_man[,c(32,38, 40:42,47,52:55,64,67,69,72,75:78,84,87:91)]


#for hybrid selection, the starting model will include only the intercept. Hence, price ~1
#currently, I am taking my answer to be based on the base X-predictors model to decide which predictor has impact on "price"
start_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_man_predictors_price)
empty_mod <- lm(price ~ 1, data = scaled_data_added_property_type_private_man_predictors_price)
full_mod <- lm(price ~ ., data = scaled_data_added_property_type_private_man_predictors_price)

hybridstepwise <- step(start_mod, 
                       scope = list(upper = full_mod, lower = empty_mod), 
                       direction = "both")
summary(hybridstepwise)
hybridstepwise


#model for private
modelprivate <- lm(price ~ zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms + cancellation_policy,
                       data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private_man)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private_man$price)^2))
rmse_entire777


#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~  neighbourhood_group_cleansed + property_type + accommodates *
                             bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                             number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms + cancellation_policy,
                           data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)



#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_out <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))



#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast")

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581)

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433)

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#replacing predicted price >= $999 to default $20
scaled_scoringData_price_huge <- scaled_scoringData_price %>%
  filter(price >= 999) %>%
  mutate (price = 999)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10 & price < 999)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative,
                                  scaled_scoringData_price_huge)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_30_le_wei_boon.csv', row.names = F)



















#Submission 31 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")




#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + calendar_updated + zipcode + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111

#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + calendar_updated + zipcode + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + calendar_updated + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + calendar_updated + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + calendar_updated + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(calendar_updated != '56 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201 | calendar_updated == '56 months ago')

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(calendar_updated != '69 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook %>%
  filter(calendar_updated == '69 months ago')

scaled_scoringData_entirehome_brook_out <- rbind(scaled_scoringData_entirehome_brook_main_zipcode_na,
                                               scaled_scoringData_entirehome_brook_out)




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(calendar_updated != '28 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach' | calendar_updated == '28 months ago')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(calendar_updated != '63 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill' | calendar_updated == '63 months ago')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(calendar_updated != '40 months ago') %>%
  filter(calendar_updated != '41 months ago') %>%
  filter(calendar_updated != '48 months ago') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside' | calendar_updated == '40 months ago' | calendar_updated == '41 months ago' | calendar_updated == '48 months ago')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_31_le_wei_boon.csv', row.names = F)









#Submission 32 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_32_le_wei_boon.csv', row.names = F)































































































#Submission 33 - lm and with usage of zipcode and host_since
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)


#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter (price >= 15)


#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)
#scaled_data_added_property_type$host_since <- as.factor(scaled_data_added_property_type$host_since)



#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~  calendar_updated * availability_30 * availability_365 + instant_bookable + host_is_superhost + neighbourhood_cleansed + zipcode + accommodates *
                            bathrooms * bedrooms + minimum_nights * minimum_maximum_nights +  guests_included * extra_people +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ availability_30 * availability_365 + instant_bookable + host_is_superhost + neighbourhood_cleansed + accommodates *
                                bathrooms * bedrooms + minimum_nights * minimum_maximum_nights +  guests_included * extra_people +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ calendar_updated * availability_30 * availability_365 + instant_bookable + neighbourhood_cleansed + zipcode + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + 
                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ availability_30 * availability_365 + instant_bookable + neighbourhood_cleansed + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + 
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ calendar_updated * availability_30 * availability_365 + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ availability_30 * availability_365 + + neighbourhood_group_cleansed + accommodates *
                                 bathrooms * bedrooms + minimum_nights +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#set.seed(1031)
#modelprivate_gbm <- gbm(price ~ cancellation_policy + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed * property_type + accommodates *
#                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                         number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_cleanliness *reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                       distribution = "gaussian",
#                       data = scaled_data_added_property_type_private,
#                       n.trees = 10000,
#                       interaction.depth = 1,
#                       shrinkage = 0.001,
#                       cv.folds = 5, 
#                       n.cores = NULL, # will use all cores by default
#                       verbose = FALSE)

#summary(modelprivate_gbm)



#set.seed(1031)
#pre <- predict(modelprivate_gbm, newdata = scaled_data_added_property_type_private)
#rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private$price)^2))
#rmse_entire









#model for private
modelprivate <- lm(price ~ calendar_updated * availability_30  * availability_365 + cancellation_policy + neighbourhood_cleansed + property_type + zipcode + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_cleanliness *reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
#modelprivate_out <- lm(price ~  availability_30  * availability_90 + cancellation_policy + neighbourhood_cleansed + property_type + accommodates *
#                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights +
#                         number_of_reviews_ltm + review_scores_rating * review_scores_location * review_scores_cleanliness *reviews_per_month * review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                       data = scaled_data_added_property_type_private)

#summary(modelprivate_out)


#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)



#using lm for shared
modelshared <- lm(price ~ calendar_updated * availability_30  * availability_90 + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights +
                    number_of_reviews_ltm + review_scores_rating * review_scores_accuracy * reviews_per_month * review_scores_communication + review_scores_value + calculated_host_listings_count_shared_rooms +
                    neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
#modelshared_out <- lm(price ~  availability_30  * availability_90 + accommodates *
#                        bathrooms + guests_included * extra_people + minimum_nights +
#                        number_of_reviews_ltm + review_scores_rating * review_scores_accuracy * reviews_per_month * review_scores_communication + review_scores_value + calculated_host_listings_count_shared_rooms +
#                        neighbourhood_group_cleansed + property_type,
#                      data = scaled_data_added_property_type_shared)

#summary(modelshared_out)

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)



#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(calendar_updated != '56 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201 | calendar_updated == '56 months ago')

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(calendar_updated != '69 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook %>%
  filter(calendar_updated == '69 months ago')

scaled_scoringData_entirehome_brook_out <- rbind(scaled_scoringData_entirehome_brook_main_zipcode_na,
                                               scaled_scoringData_entirehome_brook_out)




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(calendar_updated != '28 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach' | calendar_updated == '28 months ago')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(calendar_updated != '63 months ago') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill' | calendar_updated == '63 months ago')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(calendar_updated != '40 months ago') %>%
  filter(calendar_updated != '41 months ago') %>%
  filter(calendar_updated != '48 months ago') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside' | calendar_updated == '40 months ago' | calendar_updated == '41 months ago' | calendar_updated == '48 months ago')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 1) %>%
  mutate (price = 1)

#replacing predicted price >= $999 to default $20
scaled_scoringData_price_huge <- scaled_scoringData_price %>%
  filter(price >= 999) %>%
  mutate (price = 999)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 1 & price < 999)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative,
                                  scaled_scoringData_price_huge)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_33_le_wei_boon.csv', row.names = F)













#Submission 34 - xgboost
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)




#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#xgboost model for entirehome manhattan: xgbc_man
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_entirehome_man$price, p = 0.9, list = F)
train_man = scaled_data_added_property_type_entirehome_man[indexes, ]
test_man = scaled_data_added_property_type_entirehome_man[-indexes, ]

train_man_pred = data.matrix(train_man[, c(28, 32, 38, 40:42, 54,52,53,64,67,69,72,77,73,78,84, 91)])
train_man_price = train_man[,47]

test_man_pred = data.matrix(test_man[, c(28, 32, 38, 40:42, 54,52,53,64,67,69,72,77,73,78,84, 91)])
test_man_price = test_man[, 47]

xgb_train = xgb.DMatrix(data = train_man_pred, label = train_man_price)
xgb_test = xgb.DMatrix(data = test_man_pred, label = test_man_price)

xgbc_man = xgboost(data = xgb_train, max.depth = 2, nrounds = 300)
print(xgbc_man)

pred_y = predict(xgbc_man, xgb_test)

rmse = RMSE(test_man_price, pred_y)
rmse


#finding R-squared value of entirehomes in Manhattan
residuals = test_man_price - pred_y

test_man_price_mean = mean(test_man_price)

# Calculate total sum of squares
tss =  sum((test_man_price - test_man_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome manhattan
#modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + accommodates *
#                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                            number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value + 
#                            cancellation_policy,
#                          data = scaled_data_added_property_type_entirehome_man)

#summary(modelentirehome_man)

#pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
#rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
#rmse_entire1111



#xgboost model for entirehome manhattan: xgbc_man_out
#set.seed(100)

#train_man_out_pred = data.matrix(train_man[, c(28, 40:42, 54,52,53,64,67,69,72,77,73,78,84)])
#train_man_out_price = train_man[,47]

#test_man_out_pred = data.matrix(test_man[, c(28, 40:42, 54,52,53,64,67,69,72,77,73,78,84)])
#test_man_out_price = test_man[, 47]

#xgb_train = xgb.DMatrix(data = train_man_out_pred, label = train_man_out_price)
#xgb_test = xgb.DMatrix(data = test_man_out_pred, label = test_man_out_price)

#xgbc_man_out = xgboost(data = xgb_train, max.depth = 2, nrounds = 50)
#print(xgbc_man_out)

#pred_y = predict(xgbc_man_out, xgb_test)

#rmse = RMSE(test_man_out_price, pred_y)
#rmse










#using lm for entirehome manhattan (outliers without the same zipcode)
#modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + accommodates *
#                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value + 
#                                cancellation_policy,
#                              data = scaled_data_added_property_type_entirehome_man)

#summary(modelentirehome_man_out)


#xgboost model for entirehome brooklyn: xgbc_brook
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_entirehome_brook$price, p = 0.90, list = F)
train_brook = scaled_data_added_property_type_entirehome_brook[indexes, ]
test_brook = scaled_data_added_property_type_entirehome_brook[-indexes, ]

train_brook_pred = data.matrix(train_brook[, c(28, 32, 38, 40:42, 54,52,53,64,67,69,72,77,73,78, 91)])
train_brook_price = train_brook[,47]

test_brook_pred = data.matrix(test_brook[, c(28, 32, 38, 40:42, 54,52,53,64,67,69,72,77,73,78, 91)])
test_brook_price = test_brook[, 47]

xgb_train = xgb.DMatrix(data = train_brook_pred, label = train_brook_price)
xgb_test = xgb.DMatrix(data = test_brook_pred, label = test_brook_price)

xgbc_brook = xgboost(data = xgb_train, max.depth = 2, nrounds = 300)
print(xgbc_brook)

pred_y = predict(xgbc_brook, xgb_test)

rmse = RMSE(test_brook_price, pred_y)
rmse


#finding R-squared value of entirehomes in Brooklyn
residuals = test_brook_price - pred_y

test_brook_price_mean = mean(test_brook_price)

# Calculate total sum of squares
tss =  sum((test_brook_price - test_brook_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome brooklyn
#modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + accommodates *
#                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                              number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value,
#                            data = scaled_data_added_property_type_entirehome_brook)

#summary(modelentirehome_brook)

#pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
#rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
#rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
#modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + accommodates *
#                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                  number_of_reviews_ltm + review_scores_rating * review_scores_location + review_scores_accuracy + review_scores_value  + review_scores_rating,
#                                data = scaled_data_added_property_type_entirehome_brook)

#summary(modelentirehome_brook_out)




#xgboost model for entirehome rest: xgbc_rest
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_entirehome_rest$price, p = 0.90, list = F)
train_rest = scaled_data_added_property_type_entirehome_rest[indexes, ]
test_rest = scaled_data_added_property_type_entirehome_rest[-indexes, ]

train_rest_pred = data.matrix(train_rest[, c(28, 32, 38, 40:42, 54,52,53,64,72,77,73,91)])
train_rest_price = train_rest[,47]

test_rest_pred = data.matrix(test_rest[, c(28, 32, 38, 40:42, 54,52,53,64,72,77,73,91)])
test_rest_price = test_rest[, 47]

xgb_train = xgb.DMatrix(data = train_rest_pred, label = train_rest_price)
xgb_test = xgb.DMatrix(data = test_rest_pred, label = test_rest_price)

xgbc_rest = xgboost(data = xgb_train, max.depth = 2, nrounds = 300)
print(xgbc_rest)

pred_y = predict(xgbc_rest, xgb_test)

rmse = RMSE(test_rest_price, pred_y)
rmse

#finding R-squared value of entirehomes in rest of bouroughs
residuals = test_rest_price - pred_y

test_rest_price_mean = mean(test_rest_price)

# Calculate total sum of squares
tss =  sum((test_rest_price - test_rest_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome staten island, bronx, queens
#modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month,
#                           data = scaled_data_added_property_type_entirehome_rest)

#summary(modelentirehome_rest)
#
#pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
#rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
#rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
#modelentirehome_rest_out <- lm(price ~ accommodates *
#                                 bathrooms * bedrooms + minimum_nights + availability_30 +
#                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                               data = scaled_data_added_property_type_entirehome_rest)

#summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114






#xgboost model for private: xgbc_private
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_private$price, p = 0.80, list = F)
train_private = scaled_data_added_property_type_private[indexes, ]
test_private = scaled_data_added_property_type_private[-indexes, ]

train_private_pred = data.matrix(train_private[, c(28, 29, 32, 38, 40:42, 54,52,53,64,67,69,72,77,91,78,87,89)])
train_private_price = train_private[,47]

test_private_pred = data.matrix(test_private[, c(28, 29, 32, 38, 40:42, 54,52,53,64,67,69,72,77,91,78,87,89)])
test_private_price = test_private[, 47]

xgb_train = xgb.DMatrix(data = train_private_pred, label = train_private_price)
xgb_test = xgb.DMatrix(data = test_private_pred, label = test_private_price)

xgbc_private = xgboost(data = xgb_train, max.depth = 3, nrounds = 300)
print(xgbc_private)

pred_y = predict(xgbc_private, xgb_test)

rmse = RMSE(test_private_price, pred_y)
rmse

#finding R-squared value of private rooms
residuals = test_private_price - pred_y

test_private_price_mean = mean(test_private_price)

# Calculate total sum of squares
tss =  sum((test_private_price - test_private_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq





#model for private
#modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)

#pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
#rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
#rmse_entire777

#model for private (outliers that cannot match zipcode)
#modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                       data = scaled_data_added_property_type_private)

#summary(modelprivate_out)









#xgboost model for private: xgbc_shared
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_shared$price, p = 0.80, list = F)
train_shared = scaled_data_added_property_type_shared[indexes, ]
test_shared = scaled_data_added_property_type_shared[-indexes, ]

train_shared_pred = data.matrix(train_shared[, c(28, 29, 32, 38, 40, 41, 54,52,53,64,67,69,72,77,91,78,90)])
train_shared_price = train_shared[,47]

test_shared_pred = data.matrix(test_shared[, c(28, 29, 32, 38, 40, 41, 54,52,53,64,67,69,72,77,91,78,90)])
test_shared_price = test_shared[, 47]

xgb_train = xgb.DMatrix(data = train_shared_pred, label = train_shared_price)
xgb_test = xgb.DMatrix(data = test_shared_pred, label = test_shared_price)

xgbc_shared = xgboost(data = xgb_train, max.depth = 3, nrounds = 300)
print(xgbc_shared)

pred_y = predict(xgbc_shared, xgb_test)

rmse = RMSE(test_shared_price, pred_y)
rmse

#finding R-squared value of shared rooms
residuals = test_shared_price - pred_y

test_shared_price_mean = mean(test_shared_price)

# Calculate total sum of squares
tss =  sum((test_shared_price - test_shared_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq








#using lm for shared
#modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
#                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
#                  data = scaled_data_added_property_type_shared)

#summary(modelshared)

#pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
#rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
#rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
#modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
#                      data = scaled_data_added_property_type_shared)

#summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_34_le_wei_boon.csv', row.names = F)









#Submission 35 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_35_le_wei_boon.csv', row.names = F)




















#Submission 36 - xboost for private homes; lm for the rest
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114







#xgboost model for private: xgbc_private
set.seed(100)

indexes = createDataPartition(scaled_data_added_property_type_private$price, p = 0.80, list = F)
train_private = scaled_data_added_property_type_private[indexes, ]
test_private = scaled_data_added_property_type_private[-indexes, ]

train_private_pred = data.matrix(train_private[, c(28, 29, 32, 38, 40:42, 54,52,53,64,67,69,72,77,91,78,87,89)])
train_private_price = train_private[,47]

test_private_pred = data.matrix(test_private[, c(28, 29, 32, 38, 40:42, 54,52,53,64,67,69,72,77,91,78,87,89)])
test_private_price = test_private[, 47]

xgb_train = xgb.DMatrix(data = train_private_pred, label = train_private_price)
xgb_test = xgb.DMatrix(data = test_private_pred, label = test_private_price)

xgbc_private = xgboost(data = xgb_train, max.depth = 3, nrounds = 300)
print(xgbc_private)

pred_y = predict(xgbc_private, xgb_test)

rmse = RMSE(test_private_price, pred_y)
rmse

#finding R-squared value of private rooms
residuals = test_private_price - pred_y

test_private_price_mean = mean(test_private_price)

# Calculate total sum of squares
tss =  sum((test_private_price - test_private_price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq










#model for private
#modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
#                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                   data = scaled_data_added_property_type_private)

#summary(modelprivate)

#pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
#rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
#rmse_entire777

#model for private (outliers that cannot match zipcode)
#modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
#                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
#                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
#                       data = scaled_data_added_property_type_private)

#summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100



#predicting for private rooms_main
scaled_scoringData_private_main_pred = data.matrix(scaled_scoringData_private_main[, c(28, 29, 32, 38, 40:42, 53,51,52,63,66,68,71,76,90,77,86,88)])

xgb_test = xgb.DMatrix(data = scaled_scoringData_private_main_pred)

pred_private_main = predict(xgbc_private, xgb_test)


#predicting for private rooms_out
scaled_scoringData_private_out_pred = data.matrix(scaled_scoringData_private_out[, c(28, 29, 32, 38, 40:42, 53,51,52,63,66,68,71,76,90,77,86,88)])

xgb_test_2 = xgb.DMatrix(data = scaled_scoringData_private_out_pred)

pred_private_out = predict(xgbc_private, xgb_test_2)


pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)




scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_36_le_wei_boon.csv', row.names = F)

























































































#Submission 37 - lm and with usage of zipcode and city as well as first_review for private_main. Though R^2 value improved a lot for private_main, the RMSE is worst than submission #35 which is the best so far
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")

scaled_data_added_property_type_private_shared <- rbind(scaled_data_added_property_type_private, scaled_data_added_property_type_shared)



#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ city + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ city + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ city + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ city + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ city + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ city + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114






#model for private
modelprivate <- lm(price ~ first_review + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month * review_scores_accuracy + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ city + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ city + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_37_le_wei_boon.csv', row.names = F)












#Submission 38 - lm and with usage of zipcode with removal of 0.4% outliers
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.999)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price < highest_price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA')


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room")


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 * availability_60 * availability_90 +
                            number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                            review_scores_checkin * review_scores_value + cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111


#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 * availability_60 * availability_90 +
                                number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                                review_scores_checkin * review_scores_value + cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)


#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 * availability_60 * availability_90 +
                              number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                              review_scores_checkin * review_scores_value,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 * availability_60 * availability_90 +
                                  number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                                  review_scores_checkin * review_scores_value,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 *availability_60 * availability_90 +
                             number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                             review_scores_checkin * review_scores_value,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 * availability_60 * availability_90 +
                                 number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                                 review_scores_checkin * review_scores_value,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 * availability_60 * availability_90 +
                     number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                     review_scores_checkin * review_scores_value + 
                     calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 * availability_60 * availability_90 +
                         number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                         review_scores_checkin * review_scores_value  + 
                         calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 * availability_60 * availability_90 +
                    number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                    review_scores_checkin * review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 * availability_60 * availability_90 +
                        number_of_reviews_ltm * review_scores_rating * review_scores_location * reviews_per_month *  review_scores_cleanliness  *  review_scores_accuracy  * 
                        review_scores_checkin * review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_38_le_wei_boon.csv', row.names = F)




























#Submission 39 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price <= 500)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price <= 250)


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_39_le_wei_boon.csv', row.names = F)




























#Submission 41 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") 

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price <= 250)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price <= 125)


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_41_le_wei_boon.csv', row.names = F)




#Submission 42 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 50 & price <= 950)

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 15 & price <= 500)

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 10 & price <= 250)


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_42_le_wei_boon.csv', row.names = F)









#Submission 44 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room") 

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 15 & price <= 500)

scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 10 & price <= 250)



#using lm for entirehome
modelentirehom <- lm(price ~ neighbourhood_cleansed + neighbourhood_group_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                          data = scaled_data_added_property_type_entirehome)

summary(modelentirehom)

pre1111 <- predict(modelentirehom, newdata = scaled_data_added_property_type_entirehome)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire1111


#using lm for entirehome
modelentirehom_out <- lm(price ~ neighbourhood_cleansed + neighbourhood_group_cleansed + property_type + accommodates *
                       bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                       number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                       cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                     data = scaled_data_added_property_type_entirehome)

summary(modelentirehom_out)




#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)


#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)


scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehom, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehom_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehom, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehom_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehom, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehom_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,91)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,91)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,91)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,91)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,91)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,91)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,91)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,91)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,91)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,91)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,91)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,91)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 10) %>%
  mutate (price = 10)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 10)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_44_le_wei_boon.csv', row.names = F)














#Submission 45 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#scaled_data_added_property_type1 <- scaled_data_added_property_type[grepl("luxury", scaled_data_added_property_type[["name"]]) | 
#                                                                      grepl("luxury", scaled_data_added_property_type[["space"]]) |
#                                                                      grepl("luxury", scaled_data_added_property_type[["description"]]), ]



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex <- ex %>%
  filter(room_type != "Shared room") 

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name, scaled_scoringData2$space, scaled_scoringData2$description)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,92)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,92)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,92)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,92)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,92)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,92)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,92)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,92)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,92)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 5) %>%
  mutate (price = 5)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 5)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_45_le_wei_boon.csv', row.names = F)










#Submission 46 - lm and with usage of zipcode
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)

scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#scaled_data_added_property_type1 <- scaled_data_added_property_type[grepl("luxury", scaled_data_added_property_type[["name"]]) | 
#                                                                      grepl("luxury", scaled_data_added_property_type[["space"]]) |
#                                                                      grepl("luxury", scaled_data_added_property_type[["description"]]), ]



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex <- ex %>%
  filter(room_type != "Shared room") 

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ host_name + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111




#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ host_name + ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)



#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ host_name + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ host_name + host_name + ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ host_name + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ host_name + ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)



#modelentirehome <- lm(price ~ zipcode + property_type + accommodates *
#                             bathrooms * bedrooms + minimum_nights + availability_30 +
#                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
#                           data = scaled_data_added_property_type_entirehome)

#summary(modelentirehome)

#pre1114 <- predict(modelentirehome, newdata = scaled_data_added_property_type_entirehome)
#rmse_entire1114 <- sqrt(mean((pre1114-scaled_data_added_property_type_entirehome$price)^2))
#rmse_entire1114




#model for private
modelprivate <- lm(price ~ host_name + ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ host_name + ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)




#using lm for shared
modelshared <- lm(price ~ host_name + host_name + ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ host_name + ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData

scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)



#pred_entirehome <- predict(modelentirehome, newdata = scaled_scoringData_entirehome)
pred_entirehome_man_main <- predict(modelentirehome_man, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentirehome_man_out, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentirehome_brook, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentirehome_brook_out, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentirehome_rest, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentirehome_rest_out, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_out, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,92)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,92)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,92)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,92)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,92)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,92)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,92)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,92)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,92)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 5) %>%
  mutate (price = 5)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 5)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_46_le_wei_boon.csv', row.names = F)










#Submission 47 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#scaled_data_added_property_type1 <- scaled_data_added_property_type[grepl("luxury", scaled_data_added_property_type[["name"]]) | 
#                                                                      grepl("luxury", scaled_data_added_property_type[["space"]]) |
#                                                                      grepl("luxury", scaled_data_added_property_type[["description"]]), ]



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex <- ex %>%
  filter(room_type != "Shared room") 

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy,                       
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_entirehome_man,
                       n.trees = 5000,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire




#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)






#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_brook,
                           n.trees = 5000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire






#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_rest,
                             n.trees = 5000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private$price,SplitRatio=0.8)
scaled_data_added_property_type_private_train = scaled_data_added_property_type_private[split, ]
scaled_data_added_property_type_private_test = scaled_data_added_property_type_private[!split, ]


#training gbm for private
set.seed(1031)
modelprivate_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                          bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                          number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                        distribution = "gaussian",
                            data = scaled_data_added_property_type_private,
                            n.trees = 5000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_gbm, newdata = scaled_data_added_property_type_private)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private$price)^2))
rmse_entire




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                        data = scaled_data_added_property_type_shared,
                        n.trees = 5000,
                        interaction.depth = 3,
                        shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)




pred_entirehome_man_main <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate_gbm, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_gbm, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared_gbm, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_gbm, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,92)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,92)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,92)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,92)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,92)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,92)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,92)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,92)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,92)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 5) %>%
  mutate (price = 5)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 5)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_47_le_wei_boon.csv', row.names = F)















#Submission 48 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type


#scaled_data_added_property_type_select <- scaled_data_added_property_type %>%
#  select(accommodates, bathrooms, bedrooms, guests_included, extra_people, minimum_nights, maximum_nights,
#         availability_30, availability_365, number_of_reviews_ltm, review_scores_rating, review_scores_checkin, review_scores_communication, review_scores_location, reviews_per_month, 
#         review_scores_value, calculated_host_listings_count, calculated_host_listings_count_entire_homes, neighbourhood_group_cleansed, cancellation_policy, property_type, room_type, cleaning_fee, price)

#scaled_data_added_property_type_select <- scaled_data_added_property_type[, c(29, 38:42, 52:55, 64, 67, 69, 72, 75:78, 84, 87:92, 51, 47)]
#scaled_data_added_property_type_select_without_na <- na.omit(scaled_data_added_property_type_select)





#finding the price tagged to lowest and highest percentiles for homes
#lowest_price <- quantile(scaled_data_added_property_type$price, c(0.001)) 
#highest_price <- quantile(scaled_data_added_property_type$price, c(0.998)) 
#lowest_price
#highest_price

#removing the lowest and highest percentiles of price for "Entire home/apt"
#scaled_data_added_property_type <- scaled_data_added_property_type %>%
#  filter(price >lowest_price & price)
#min(scaled_data_added_property_type$price)
#max(scaled_data_added_property_type$price)




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)

#scaled_data_added_property_type1 <- scaled_data_added_property_type[grepl("luxury", scaled_data_added_property_type[["name"]]) | 
#                                                                      grepl("luxury", scaled_data_added_property_type[["space"]]) |
#                                                                      grepl("luxury", scaled_data_added_property_type[["description"]]), ]



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex <- ex %>%
  filter(room_type != "Shared room") 

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)

#remove the rows with NA under zipcode
#scaled_data_added_property_type <- scaled_data_added_property_type %>% drop_na(zipcode)


scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan and Brooklyn
#scaled_data_added_property_type_entirehome_man_brook <- scaled_data_added_property_type_entirehome %>%
#  filter(neighbourhood_group_cleansed == c("Manhattan", "Brooklyn"))

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")

scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)


scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 6000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire




#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)






#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 6000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire






#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 6000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private$price,SplitRatio=0.8)
scaled_data_added_property_type_private_train = scaled_data_added_property_type_private[split, ]
scaled_data_added_property_type_private_test = scaled_data_added_property_type_private[!split, ]


#training gbm for private
set.seed(1031)
modelprivate_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                          bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                          number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                        distribution = "gaussian",
                        data = scaled_data_added_property_type_private,
                        n.trees = 6000,
                        interaction.depth = 3,
                        shrinkage = 0.01)

summary(modelprivate_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_gbm, newdata = scaled_data_added_property_type_private)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private$price)^2))
rmse_entire




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 6000,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL",
           "Luxurious")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#removing the 2 IDs are the two outliers in manhattan with zipcodes of 10020 and 11201
scaled_scoringData_entirehome_man_main <- scaled_scoringData_entirehome_man %>%
  filter(id != 27759863) %>%
  filter(id != 33763795) %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_man_main_zipcode_na <- subset(scaled_scoringData_entirehome_man, is.na(zipcode))
#separating out the 2 IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan
scaled_scoringData_entirehome_man_out <- scaled_scoringData_entirehome_man %>%
  filter(zipcode == 10020 | zipcode == 11201)

scaled_scoringData_entirehome_man_out <- rbind(scaled_scoringData_entirehome_man_main_zipcode_na,
                                               scaled_scoringData_entirehome_man_out)




#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 

#removing the rows in brooklyn with NA zipcode
scaled_scoringData_entirehome_brook_main <- scaled_scoringData_entirehome_brook %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_brook_main_zipcode_na <- subset(scaled_scoringData_entirehome_brook, is.na(zipcode))
#separating out the IDs that are outliers in manhattan. These will be predicted with the outlier model for manhattan


scaled_scoringData_entirehome_brook_out <- scaled_scoringData_entirehome_brook_main_zipcode_na




#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")

#removing the 7 IDs are the two outliers in the rest with zipcodes of 11237, 11362, 11363, 11426 and property_type = Bed and breakfast
scaled_scoringData_entirehome_rest_main <- scaled_scoringData_entirehome_rest %>%
  filter(id != 18387789) %>%
  filter(id != 20292477) %>%
  filter(id != 20347353) %>%
  filter(id != 23098266) %>%
  filter(id != 28805705) %>%
  filter(id != 30696721) %>%
  filter(id != 5551032) %>%
  filter(neighbourhood_cleansed != 'Lighthouse Hill') %>%
  filter(neighbourhood_cleansed != 'South Beach') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_entirehome_rest_main_zipcode_na <- subset(scaled_scoringData_entirehome_rest, is.na(zipcode))
#separating out the that are outliers on postal code and property_type in the rest. These will be predicted with the outlier model for the rest
scaled_scoringData_entirehome_rest_out <- scaled_scoringData_entirehome_rest %>%
  filter(zipcode == 11237 | zipcode == 11362 | zipcode == 11363 | zipcode == 11426 | property_type == "Bed and breakfast" | neighbourhood_cleansed == 'Lighthouse Hill' | neighbourhood_cleansed == 'South Beach')

scaled_scoringData_entirehome_rest_out <- rbind(scaled_scoringData_entirehome_rest_main_zipcode_na,
                                                scaled_scoringData_entirehome_rest_out)




scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#keeping the rest of data in private that are not outliers
scaled_scoringData_private_main <- scaled_scoringData_private %>%
  filter(id != 30838350) %>%
  filter(neighbourhood_cleansed != 'Arden Heights') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace') %>%
  filter(neighbourhood_cleansed != 'Staten Island') %>%
  filter(neighbourhood_cleansed != 'Bay Terrace, Staten Island') %>%
  filter(neighbourhood_cleansed != 'Breezy Point') %>%
  filter(neighbourhood_cleansed != 'Gerritsen Beach') %>%
  filter(neighbourhood_cleansed != 'Holliswood') %>%
  filter(neighbourhood_cleansed != 'Sea Gate') %>%
  filter(neighbourhood_cleansed != 'Silver Lake') %>%
  filter(neighbourhood_cleansed != 'Todt Hill') %>%
  filter(zipcode != 'NA')

#pulling out rows with zipcode as NA
scaled_scoringData_private_main_zipcode_na <- subset(scaled_scoringData_private, is.na(zipcode))
#separating out the 1 ID that is outlier in private rooms. This will be predicted with the outlier model for private
scaled_scoringData_private_out <- scaled_scoringData_private %>%
  filter(zipcode == 11581 | neighbourhood_cleansed == 'Arden Heights' | neighbourhood_cleansed == 'Bay Terrace' | neighbourhood_cleansed == 'Staten Island' | 
           neighbourhood_cleansed == 'Bay Terrace, Staten Island' | neighbourhood_cleansed == 'Breezy Point' | 
           neighbourhood_cleansed == 'Gerritsen Beach' | neighbourhood_cleansed == 'Holliswood' | neighbourhood_cleansed == 'Sea Gate' | neighbourhood_cleansed == 'Silver Lake' | 
           neighbourhood_cleansed == 'Todt Hill')

scaled_scoringData_private_out <- rbind(scaled_scoringData_private_main_zipcode_na,
                                        scaled_scoringData_private_out)




#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)




pred_entirehome_man_main <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man_main)
pred_entirehome_man_out <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man_out)

pred_entirehome_brook_main <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook_main)
pred_entirehome_brook_out <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook_out)

pred_entirehome_rest_main <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest_main)
pred_entirehome_rest_out <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest_out)


pred_cabin <- predict(modelprivate_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- 100

pred_private_main <- predict(modelprivate_gbm, newdata = scaled_scoringData_private_main)
pred_private_out <- predict(modelprivate_gbm, newdata = scaled_scoringData_private_out)

pred_shared_main <- predict(modelshared_gbm, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_gbm, newdata = scaled_scoringData_shared_out)





scaled_scoringData_entirehome_man_main$price <- pred_entirehome_man_main
scaled_scoringData_entirehome_man_out$price <- pred_entirehome_man_out

scaled_scoringData_entirehome_brook_main$price <- pred_entirehome_brook_main
scaled_scoringData_entirehome_brook_out$price <- pred_entirehome_brook_out

scaled_scoringData_entirehome_rest_main$price <- pred_entirehome_rest_main
scaled_scoringData_entirehome_rest_out$price <- pred_entirehome_rest_out

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_main$price <- pred_private_main
scaled_scoringData_private_out$price <- pred_private_out

scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out




scaled_scoringData_entirehome_man_main_id_price <- scaled_scoringData_entirehome_man_main [, c(1,92)]
scaled_scoringData_entirehome_man_out_id_price <- scaled_scoringData_entirehome_man_out [, c(1,92)]

scaled_scoringData_entirehome_brook_main_id_price <- scaled_scoringData_entirehome_brook_main [, c(1,92)]
scaled_scoringData_entirehome_brook_out_id_price <- scaled_scoringData_entirehome_brook_out [, c(1,92)]

scaled_scoringData_entirehome_rest_main_id_price <- scaled_scoringData_entirehome_rest_main [, c(1,92)]
scaled_scoringData_entirehome_rest_out_id_price <- scaled_scoringData_entirehome_rest_out [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_main_id_price <- scaled_scoringData_private_main [, c(1,92)]
scaled_scoringData_private_out_id_price <- scaled_scoringData_private_out [, c(1,92)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,92)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,92)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_main_id_price,
                                  scaled_scoringData_entirehome_man_out_id_price,
                                  scaled_scoringData_entirehome_brook_main_id_price,
                                  scaled_scoringData_entirehome_brook_out_id_price,
                                  scaled_scoringData_entirehome_rest_main_id_price,
                                  scaled_scoringData_entirehome_rest_out_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_main_id_price,
                                  scaled_scoringData_private_out_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $20
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 5) %>%
  mutate (price = 5)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 5)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_48_le_wei_boon.csv', row.names = F)








#Submission 49 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 6000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire




#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 6000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire






#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 6000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                           data = scaled_data_added_property_type_private_man,
                           n.trees = 6000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire





#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                             data = scaled_data_added_property_type_private_brook,
                             n.trees = 6000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire



#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                            data = scaled_data_added_property_type_private_rest,
                            n.trees = 6000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 6000,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)

pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_49_le_wei_boon.csv', row.names = F)
















#Submission 51 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhattan
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 10000,
                           interaction.depth = 3,
                           shrinkage = 0.01,
                           n.minobsinnode = 10)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire




#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 10000,
                             interaction.depth = 3,
                             shrinkage = 0.01,
                             n.minobsinnode = 10)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire






#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 10000,
                            interaction.depth = 3,
                            shrinkage = 0.01,
                            n.minobsinnode = 10)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 10000,
                            interaction.depth = 3,
                            shrinkage = 0.01,
                            n.minobsinnode = 10)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire





#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 10000,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 10)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire



#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 10000,
                             interaction.depth = 3,
                             shrinkage = 0.01,
                             n.minobsinnode = 10)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 10000,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 10)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelentire_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)

pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#replacing predicted price >= $999 to default $20
scaled_scoringData_price_huge <- scaled_scoringData_price %>%
  filter(price >= 999) %>%
  mutate (price = 999)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0 & price < 999)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative,
                                  scaled_scoringData_price_huge)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]


#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_51_le_wei_boon.csv', row.names = F)









#Submission 52 - xgboost 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)






#xgboost model for entire in manhattan
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


scaled_data_added_property_type_entirehome_man_train_pred = data.matrix(scaled_data_added_property_type_entirehome_man_train[, c("ex",  "neighbourhood_cleansed",
                                                                                                                                     "zipcode", "property_type", "accommodates",
                                                                                                                                    "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                                    "guests_included", "extra_people", "availability_30",
                                                                                                                                    "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                                    "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                                    "review_scores_value", "review_scores_rating", 
                                                                                                                                    "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_man_train_price = scaled_data_added_property_type_entirehome_man_train[,47]


scaled_data_added_property_type_entirehome_man_test_pred = data.matrix(scaled_data_added_property_type_entirehome_man_test[, c("ex",  "neighbourhood_cleansed",
                                                                                                                                     "zipcode", "property_type", "accommodates",
                                                                                                                                     "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                                     "guests_included", "extra_people", "availability_30",
                                                                                                                                     "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                                     "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                                     "review_scores_value", "review_scores_rating", 
                                                                                                                                     "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_man_test_price = scaled_data_added_property_type_entirehome_man_test[,47]


scaled_data_added_property_type_entirehome_man_pred = data.matrix(scaled_data_added_property_type_entirehome_man[, c("ex",  "neighbourhood_cleansed",
                                                                                                                               "zipcode", "property_type", "accommodates",
                                                                                                                               "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                               "guests_included", "extra_people", "availability_30",
                                                                                                                               "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                               "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                               "review_scores_value", "review_scores_rating", 
                                                                                                                               "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_man_price = scaled_data_added_property_type_entirehome_man[,47]



xgb_train = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_man_train_pred, label = scaled_data_added_property_type_entirehome_man_train_price)
xgb_test = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_man_test_pred, label = scaled_data_added_property_type_entirehome_man_test_price)

xgb_final = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_man_pred, label = scaled_data_added_property_type_entirehome_man_price)


xgb_entire_man = xgboost(data = xgb_final, max.depth = 3, nrounds = 230)
print(xgb_entire_man)

pred_y = predict(xgb_entire_man, xgb_test)

rmse = RMSE(scaled_data_added_property_type_entirehome_man_test$price, pred_y)
rmse

#finding R-squared value 
residuals = scaled_data_added_property_type_entirehome_man_test$price - pred_y

price_mean = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]

#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man_train,
                           n.trees = 6000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value 
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

price_mean = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq



#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)








#xgboost model for entire in brook
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


scaled_data_added_property_type_entirehome_brook_train_pred = data.matrix(scaled_data_added_property_type_entirehome_brook_train[, c("ex", "neighbourhood_cleansed", "zipcode", "property_type", "accommodates",
                                                                                                                                       "bathrooms", "bedrooms", "minimum_nights", "guests_included", "extra_people", "availability_30", "availability_365",
                                                                                                                                       "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_accuracy", "review_scores_value", "review_scores_rating",
                                                                                                                                       "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_brook_train_price = scaled_data_added_property_type_entirehome_brook_train[,47]


scaled_data_added_property_type_entirehome_brook_test_pred = data.matrix(scaled_data_added_property_type_entirehome_brook_test[, c("ex", "neighbourhood_cleansed", "zipcode", "property_type", "accommodates",
                                                                                                                                   "bathrooms", "bedrooms", "minimum_nights", "guests_included", "extra_people", "availability_30", "availability_365",
                                                                                                                                   "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_accuracy", "review_scores_value", "review_scores_rating",
                                                                                                                                   "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_brook_test_price = scaled_data_added_property_type_entirehome_brook_test[,47]


scaled_data_added_property_type_entirehome_brook_pred = data.matrix(scaled_data_added_property_type_entirehome_brook[, c("ex",  "neighbourhood_cleansed",
                                                                                                                     "zipcode", "property_type", "accommodates",
                                                                                                                     "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                     "guests_included", "extra_people", "availability_30",
                                                                                                                     "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                     "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                     "review_scores_value", "review_scores_rating", 
                                                                                                                     "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_brook_price = scaled_data_added_property_type_entirehome_brook[,47]



xgb_train = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_brook_train_pred, label = scaled_data_added_property_type_entirehome_brook_train_price)
xgb_test = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_brook_test_pred, label = scaled_data_added_property_type_entirehome_brook_test_price)

xgb_final = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_brook_pred, label = scaled_data_added_property_type_entirehome_brook_price)


xgb_entire_brook = xgboost(data = xgb_final, max.depth = 3, nrounds = 180)
print(xgb_entire_brook)

pred_y = predict(xgb_entire_brook, xgb_test)

rmse = RMSE(scaled_data_added_property_type_entirehome_brook_test$price, pred_y)
rmse

#finding R-squared value 
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pred_y

price_mean = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 6000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire






#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)





#xgboost model for entire in rest
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


scaled_data_added_property_type_entirehome_rest_train_pred = data.matrix(scaled_data_added_property_type_entirehome_rest_train[, c("ex", "neighbourhood_cleansed", "zipcode", "property_type", "accommodates",
                                                                                                                                     "bathrooms", "bedrooms", "minimum_nights", "guests_included", "extra_people", "availability_30", "availability_365",
                                                                                                                                     "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_accuracy", "review_scores_value", "review_scores_rating",
                                                                                                                                     "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_rest_train_price = scaled_data_added_property_type_entirehome_rest_train[,47]


scaled_data_added_property_type_entirehome_rest_test_pred = data.matrix(scaled_data_added_property_type_entirehome_rest_test[, c("ex", "neighbourhood_cleansed", "zipcode", "property_type", "accommodates",
                                                                                                                                   "bathrooms", "bedrooms", "minimum_nights", "guests_included", "extra_people", "availability_30", "availability_365",
                                                                                                                                   "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_accuracy", "review_scores_value", "review_scores_rating",
                                                                                                                                   "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_rest_test_price = scaled_data_added_property_type_entirehome_rest_test[,47]


scaled_data_added_property_type_entirehome_rest_pred = data.matrix(scaled_data_added_property_type_entirehome_rest[, c("ex",  "neighbourhood_cleansed",
                                                                                                                         "zipcode", "property_type", "accommodates",
                                                                                                                         "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                         "guests_included", "extra_people", "availability_30",
                                                                                                                         "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                         "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                         "review_scores_value", "review_scores_rating", 
                                                                                                                         "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])

scaled_data_added_property_type_entirehome_rest_price = scaled_data_added_property_type_entirehome_rest[,47]



xgb_train = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_rest_train_pred, label = scaled_data_added_property_type_entirehome_rest_train_price)
xgb_test = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_rest_test_pred, label = scaled_data_added_property_type_entirehome_rest_test_price)

xgb_final = xgb.DMatrix(data = scaled_data_added_property_type_entirehome_rest_pred, label = scaled_data_added_property_type_entirehome_rest_price)


xgb_entire_rest = xgboost(data = xgb_final, max.depth = 3, nrounds = 190)
print(xgb_entire_rest)

pred_y = predict(xgb_entire_rest, xgb_test)

rmse = RMSE(scaled_data_added_property_type_entirehome_rest_test$price, pred_y)
rmse

#finding R-squared value 
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pred_y

price_mean = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq




#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 6000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#xgboost model for private in man
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


scaled_data_added_property_type_private_man_train_pred = data.matrix(scaled_data_added_property_type_private_man_train[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                                           "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                                             "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_man_train_price = scaled_data_added_property_type_private_man_train[,47]


scaled_data_added_property_type_private_man_test_pred = data.matrix(scaled_data_added_property_type_private_man_test[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                                         "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                                         "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_man_test_price = scaled_data_added_property_type_private_man_test[,47]


scaled_data_added_property_type_private_man_pred = data.matrix(scaled_data_added_property_type_private_man[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                               "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                               "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_man_price = scaled_data_added_property_type_private_man[,47]



xgb_train = xgb.DMatrix(data = scaled_data_added_property_type_private_man_train_pred, label = scaled_data_added_property_type_private_man_train_price)
xgb_test = xgb.DMatrix(data = scaled_data_added_property_type_private_man_test_pred, label = scaled_data_added_property_type_private_man_test_price)

xgb_final = xgb.DMatrix(data = scaled_data_added_property_type_private_man_pred, label = scaled_data_added_property_type_private_man_price)


xgb_private_man = xgboost(data = xgb_final, max.depth = 3, nrounds = 30)
print(xgb_private_man)

pred_y = predict(xgb_private_man, xgb_test)

rmse = RMSE(scaled_data_added_property_type_private_man_test$price, pred_y)
rmse

#finding R-squared value 
residuals = scaled_data_added_property_type_private_man_test$price - pred_y

price_mean = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 6000,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire







#xgboost model for private in brook
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


scaled_data_added_property_type_private_brook_train_pred = data.matrix(scaled_data_added_property_type_private_brook_train[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                                           "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                                           "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_brook_train_price = scaled_data_added_property_type_private_brook_train[,47]


scaled_data_added_property_type_private_brook_test_pred = data.matrix(scaled_data_added_property_type_private_brook_test[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                                         "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                                         "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_brook_test_price = scaled_data_added_property_type_private_brook_test[,47]


scaled_data_added_property_type_private_brook_pred = data.matrix(scaled_data_added_property_type_private_brook[, c("ex", "neighbourhood_cleansed", "zipcode", "neighbourhood_group_cleansed", "property_type",
                                                                                                               "accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people","minimum_nights", "availability_30", "availability_365",
                                                                                                               "number_of_reviews_ltm", "review_scores_rating", "review_scores_location", "reviews_per_month", "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_private_rooms")])

scaled_data_added_property_type_private_brook_price = scaled_data_added_property_type_private_brook[,47]



xgb_train = xgb.DMatrix(data = scaled_data_added_property_type_private_brook_train_pred, label = scaled_data_added_property_type_private_brook_train_price)
xgb_test = xgb.DMatrix(data = scaled_data_added_property_type_private_brook_test_pred, label = scaled_data_added_property_type_private_brook_test_price)

xgb_final = xgb.DMatrix(data = scaled_data_added_property_type_private_brook_pred, label = scaled_data_added_property_type_private_brook_price)


xgb_private_brook = xgboost(data = xgb_final, max.depth = 3, nrounds = 50)
print(xgb_private_brook)

pred_y = predict(xgb_private_brook, xgb_test)

rmse = RMSE(scaled_data_added_property_type_private_brook_test$price, pred_y)
rmse

#finding R-squared value 
residuals = scaled_data_added_property_type_private_brook_test$price - pred_y

price_mean = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - price_mean)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared
rsq  =  1 - (rss/tss)
rsq







#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 6000,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire



#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 6000,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 6000,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



#converting to matrix before it can predict
scaled_scoringData_entirehome_man_pred = data.matrix(scaled_scoringData_entirehome_man[, c("ex",  "neighbourhood_cleansed",
                                                                                                                     "zipcode", "property_type", "accommodates",
                                                                                                                     "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                     "guests_included", "extra_people", "availability_30",
                                                                                                                     "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                     "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                     "review_scores_value", "review_scores_rating", 
                                                                                                                     "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])


scaled_scoringData_entirehome_man_pred = xgb.DMatrix(data = scaled_scoringData_entirehome_man_pred)

#converting to matrix before it can predict
scaled_scoringData_entirehome_rest_pred = data.matrix(scaled_scoringData_entirehome_rest[, c("ex",  "neighbourhood_cleansed",
                                                                                                                       "zipcode", "property_type", "accommodates",
                                                                                                                       "bathrooms", "bedrooms", "minimum_nights",
                                                                                                                       "guests_included", "extra_people", "availability_30",
                                                                                                                       "availability_365", "number_of_reviews_ltm","review_scores_rating",
                                                                                                                       "review_scores_location", "reviews_per_month", "review_scores_accuracy",
                                                                                                                       "review_scores_value", "review_scores_rating", 
                                                                                                                       "cancellation_policy", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes")])



scaled_scoringData_entirehome_rest_pred = xgb.DMatrix(data = scaled_scoringData_entirehome_rest_pred)


#prediction
pred_entirehome_man <- predict(xgb_entire_man, newdata = scaled_scoringData_entirehome_man_pred)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(xgb_entire_rest, newdata = scaled_scoringData_entirehome_rest_pred)

pred_cabin <- predict(modelprivate_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)

pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_52_le_wei_boon.csv', row.names = F)

















#Submission 53 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 70,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)

pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_53_le_wei_boon.csv', row.names = F)
















#Submission 54 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 5000,
                       interaction.depth = 3,
                       shrinkage = 0.01)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)

pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_54_le_wei_boon.csv', row.names = F)











#Submission 55 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")



#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")

#retaining those non-outliers in shared rooms. 
scaled_scoringData_shared_main <- scaled_scoringData_shared %>%
  filter(id != 8081689) %>%
  filter(id != 10139641) %>%
  filter(id != 20336287) %>%
  filter(id != 29489017) %>%
  filter(id != 34227583) %>%
  filter(neighbourhood_cleansed != 'Bronxdale') %>%
  filter(neighbourhood_cleansed != 'Canarsie') %>%
  filter(neighbourhood_cleansed != 'Morris Heights') %>%
  filter(neighbourhood_cleansed != 'Norwood') %>%
  filter(neighbourhood_cleansed != 'Riverdale') %>%
  filter(neighbourhood_cleansed != 'Windsor Terrace') %>%
  filter(neighbourhood_cleansed != 'Woodside') %>%
  filter(zipcode != 'NA')





#pulling out rows with zipcode as NA
scaled_scoringData_shared_main_zipcode_na <- subset(scaled_scoringData_shared, is.na(zipcode))
#separating out the outliers in shared rooms. For zipcode of 10471, 10472, 11234, 11354, 11433
scaled_scoringData_shared_out <- scaled_scoringData_shared %>%
  filter(zipcode == 10471 | zipcode == 10472 | zipcode == 11234 | zipcode == 11354 | zipcode == 11433 |
           neighbourhood_cleansed == 'Bronxdale' | neighbourhood_cleansed == 'Canarsie' | neighbourhood_cleansed == 'Morris Heights' |
           neighbourhood_cleansed == 'Norwood' | neighbourhood_cleansed == 'Riverdale' | neighbourhood_cleansed == 'Windsor Terrace' |
           neighbourhood_cleansed == 'Woodside')

scaled_scoringData_shared_out <- rbind(scaled_scoringData_shared_main_zipcode_na,
                                       scaled_scoringData_shared_out)





pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared_main <- predict(modelshared, newdata = scaled_scoringData_shared_main)
pred_shared_out <- predict(modelshared_out, newdata = scaled_scoringData_shared_out)




scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest


scaled_scoringData_shared_main$price <- pred_shared_main
scaled_scoringData_shared_out$price <- pred_shared_out


scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_main_id_price <- scaled_scoringData_shared_main [, c(1,92)]
scaled_scoringData_shared_out_id_price <- scaled_scoringData_shared_out [, c(1,92)]


scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_main_id_price,
                                  scaled_scoringData_shared_out_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_55_le_wei_boon.csv', row.names = F)





#Submission 56 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_56_le_wei_boon.csv', row.names = F)












#Submission 57 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 250)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_57_le_wei_boon.csv', row.names = F)













#Submission 58 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 700)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_58_le_wei_boon.csv', row.names = F)













#Submission 59 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 500) 

#max(scaled_data_added_property_type_private$price[scaled_data_added_property_type_private$neighbourhood_group_cleansed == "Queens"])


#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)


#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in rest
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 350,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire






#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,29,39,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,29,39,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,29,39,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,29,39,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,29,39,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,29,39,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,29,39,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,29,39,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,29,39,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
#submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, neighbourhood = scaled_scoringData_price_ordered$neighbourhood_group_cleansed, room_type = scaled_scoringData_price_ordered$room_type, price = scaled_scoringData_price_ordered$price)
#write.csv(submissionFile, 'submission_59_le_wei_boon.csv', row.names = F)

submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_59_le_wei_boon.csv', row.names = F)
























#Submission 60 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 700)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_queens,
                             n.trees = 750,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens$price)^2))
rmse_entire





#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_60_le_wei_boon.csv', row.names = F)







#Submission 61 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan") %>%
  filter(price > 70)

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")%>%
  filter(price > 59)


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens") %>%
  filter(price > 50)



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan") %>%
  filter(price > 35)

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")  %>%
  filter(price > 30 & price < 550)

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")%>%
  filter(price > 25 & price < 425)




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 10 & price < 250)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire







#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 750,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens$price)^2))
rmse_entire





#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 450,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire










#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_61_le_wei_boon.csv', row.names = F)





#Submission 62 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)
scaled_data_added_property_type$calendar_updated <- as.factor(scaled_data_added_property_type$calendar_updated)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 700)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)







#starting to traing gbm for entirehomes 
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_train = scaled_data_added_property_type_entirehome[split, ]
scaled_data_added_property_type_entirehome_test = scaled_data_added_property_type_entirehome[!split, ]


#training gbm for entire homes
set.seed(1031)
modelentire_gbm <- gbm(price ~ ex + neighbourhood_group_cleansed + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             calendar_updated + cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome,
                           n.trees = 3000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_gbm, newdata = scaled_data_added_property_type_entirehome)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome$price - pre

scaled_data_added_property_type_entirehome_meanprice = mean(scaled_data_added_property_type_entirehome$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome$price - scaled_data_added_property_type_entirehome_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq














#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             calendar_updated + cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man$price - pre

scaled_data_added_property_type_entirehome_man_meanprice = mean(scaled_data_added_property_type_entirehome_man$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man$price - scaled_data_added_property_type_entirehome_man_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               calendar_updated + cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook$price - pre

scaled_data_added_property_type_entirehome_brook_meanprice = mean(scaled_data_added_property_type_entirehome_brook$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook$price - scaled_data_added_property_type_entirehome_brook_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                calendar_updated + cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 1200,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens$price - pre

scaled_data_added_property_type_entirehome_queens_meanprice = mean(scaled_data_added_property_type_entirehome_queens$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens$price - scaled_data_added_property_type_entirehome_queens_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq



#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest$price - pre

scaled_data_added_property_type_entirehome_rest_meanprice = mean(scaled_data_added_property_type_entirehome_rest$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest$price - scaled_data_added_property_type_entirehome_rest_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq


#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              calendar_updated + number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1200,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man$price - pre

scaled_data_added_property_type_private_man_meanprice = mean(scaled_data_added_property_type_private_man$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man$price - scaled_data_added_property_type_private_man_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq



#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                calendar_updated + number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 800,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook$price - pre

scaled_data_added_property_type_private_brook_meanprice = mean(scaled_data_added_property_type_private_brook$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook$price - scaled_data_added_property_type_private_brook_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               calendar_updated + number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest$price - pre

scaled_data_added_property_type_private_rest_meanprice = mean(scaled_data_added_property_type_private_rest$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest$price - scaled_data_added_property_type_private_rest_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         calendar_updated + number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 175,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_shared$price - pre

scaled_data_added_property_type_shared_meanprice = mean(scaled_data_added_property_type_shared$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared$price - scaled_data_added_property_type_shared_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq



#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)
scaled_scoringData$calendar_updated <- as.factor(scaled_scoringData$calendar_updated)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")


pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_62_le_wei_boon.csv', row.names = F)






#Submission 63 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type




scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 700)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man$price - pre

scaled_data_added_property_type_entirehome_man_meanprice = mean(scaled_data_added_property_type_entirehome_man$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man$price - scaled_data_added_property_type_entirehome_man_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire







#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 750,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens$price)^2))
rmse_entire





#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire





#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man$price)^2))
rmse_entire




#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 800,
                              interaction.depth = 3,
                              shrinkage = 0.01)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook$price)^2))
rmse_entire








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 200,
                             interaction.depth = 3,
                             shrinkage = 0.01)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest$price)^2))
rmse_entire







#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared$price)^2))
rmse_entire






#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_64_le_wei_boon.csv', row.names = F)











#Submission 65 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0 & price < 800)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 250)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 4000,
                           interaction.depth = 3,
                           shrinkage = 0.01,
                           n.minobsinnode = 20,
                           cv.folds = 5)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 3,
                             shrinkage = 0.01,
                             n.minobsinnode = 20,
                             cv.folds = 5)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 750,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 12)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 3,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 3,
                            shrinkage = 0.01,
                            n.minobsinnode = 15)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 800,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 3,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_65_le_wei_boon.csv', row.names = F)









#Submission 66 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy","cleaning_fee"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 500)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3637,
                           interaction.depth = 8,
                           shrinkage = 0.01,
                           n.minobsinnode = 20)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 8,
                             shrinkage = 0.01,
                             n.minobsinnode = 20,
                             cv.folds = 5)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 750,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 12)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 8,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 7,
                            shrinkage = 0.01,
                            n.minobsinnode = 15)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 800,
                              interaction.depth = 2,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 2,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777

#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy", "cleaning_fee"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_66_le_wei_boon.csv', row.names = F)











#Submission 67 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy","cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0
scaled_data_added_property_type$security_deposit[is.na(scaled_data_added_property_type$security_deposit)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 500)





#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ security_deposit + cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3637,
                           interaction.depth = 8,
                           shrinkage = 0.01,
                           n.minobsinnode = 20)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ security_deposit + cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                               cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1100,
                             interaction.depth = 8,
                             shrinkage = 0.01,
                             n.minobsinnode = 20,
                             cv.folds = 5)

summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ security_deposit + cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 750,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 12)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 8,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1100,
                            interaction.depth = 7,
                            shrinkage = 0.01,
                            n.minobsinnode = 15)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 800,
                              interaction.depth = 2,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ cleaning_fee + ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 2,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777





#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", 
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy", "cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0
scaled_scoringData$security_deposit[is.na(scaled_scoringData$security_deposit)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt" & property_type != "Cabin")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_scoringData_cabin <- scaled_scoringData %>%
  filter(property_type == "Cabin")

scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)

pred_cabin <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_cabin)
pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest

scaled_scoringData_cabin$price <- pred_cabin
scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]

scaled_scoringData_cabin_id_price <- scaled_scoringData_cabin [, c(1,92)]
scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_cabin_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_67_le_wei_boon.csv', row.names = F)









#Submission 68 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy","cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0
scaled_data_added_property_type$security_deposit[is.na(scaled_data_added_property_type$security_deposit)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 500)



#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews + review_scores_rating + review_scores_accuracy + review_scores_cleanliness + review_scores_value + reviews_per_month + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3637,
                           interaction.depth = 8,
                           shrinkage = 0.010,
                           n.minobsinnode = 25)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating + review_scores_location + review_scores_accuracy +reviews_per_month+ review_scores_value +
                               cancellation_policy + calculated_host_listings_count,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1083,
                             interaction.depth = 15,
                             shrinkage = 0.009,
                             n.minobsinnode = 50)


summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ host_listings_count + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count + calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 656,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 11)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 8,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1071,
                            interaction.depth = 7,
                            shrinkage = 0.01,
                            n.minobsinnode = 30)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 850,
                              interaction.depth = 2,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews + review_scores_rating * review_scores_location * reviews_per_month + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 2,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777





#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights_avg_ntm + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy", "cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0
scaled_scoringData$security_deposit[is.na(scaled_scoringData$security_deposit)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")



scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)


pred_hotel <- 100

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest


scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]


scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_68_le_wei_boon.csv', row.names = F)









#Submission 69 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy","cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0
scaled_data_added_property_type$security_deposit[is.na(scaled_data_added_property_type$security_deposit)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0 & price < 500)



#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews + review_scores_rating + review_scores_accuracy + review_scores_cleanliness + review_scores_value + reviews_per_month + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3637,
                           interaction.depth = 8,
                           shrinkage = 0.010,
                           n.minobsinnode = 25)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating + review_scores_location + review_scores_accuracy +reviews_per_month+ review_scores_value +
                               cancellation_policy + calculated_host_listings_count,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1083,
                             interaction.depth = 15,
                             shrinkage = 0.009,
                             n.minobsinnode = 50)


summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + host_listings_count + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count + calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 656,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 11)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 8,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1071,
                            interaction.depth = 7,
                            shrinkage = 0.01,
                            n.minobsinnode = 30)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 850,
                              interaction.depth = 2,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews + review_scores_rating * review_scores_location * reviews_per_month + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 2,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777





#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights_avg_ntm + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy", "cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0
scaled_scoringData$security_deposit[is.na(scaled_scoringData$security_deposit)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")



scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)


pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest


scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]


scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_69_le_wei_boon.csv', row.names = F)














#Submission 70 - glm 
#using interaction terms in the model instead of purely silo independent terms
#using back the same predictors as Submission #5 which has the additional "property_type"
#with standardization of numeric variables in the "data_added_property_type" and "scoringData"
scaled_data_added_property_type  <- data_added_property_type %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy","cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_data_added_property_type

scaled_data_added_property_type$cleaning_fee[is.na(scaled_data_added_property_type$cleaning_fee)] <- 0
scaled_data_added_property_type$security_deposit[is.na(scaled_data_added_property_type$security_deposit)] <- 0


scaled_data_added_property_type$neighbourhood_group_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_group_cleansed)
scaled_data_added_property_type$neighbourhood_cleansed <- as.factor(scaled_data_added_property_type$neighbourhood_cleansed)
scaled_data_added_property_type$cancellation_policy <- as.factor(scaled_data_added_property_type$cancellation_policy)
scaled_data_added_property_type$property_type <- as.factor(scaled_data_added_property_type$property_type)
scaled_data_added_property_type$zipcode <- as.factor(scaled_data_added_property_type$zipcode)



words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_data_added_property_type2 <- scaled_data_added_property_type
ex <- scaled_data_added_property_type2[rowSums(sapply(words, grepl, scaled_data_added_property_type2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_data_added_property_type2_ex<- scaled_data_added_property_type2[scaled_data_added_property_type2$id %in% index, ]
scaled_data_added_property_type2_not_ex<- scaled_data_added_property_type2[!scaled_data_added_property_type2$id %in% index, ]

scaled_data_added_property_type2_ex$ex = 1
scaled_data_added_property_type2_not_ex$ex = 0

scaled_data_added_property_type2 <- rbind(scaled_data_added_property_type2_ex,
                                          scaled_data_added_property_type2_not_ex)

scaled_data_added_property_type2 <- scaled_data_added_property_type2[order(scaled_data_added_property_type2$id, decreasing = FALSE), ]

scaled_data_added_property_type <- scaled_data_added_property_type2


scaled_data_added_property_type3 <- scaled_data_added_property_type2_ex %>%
  select(name, zipcode, neighbourhood_group_cleansed, room_type, price)




scaled_data_added_property_type_entirehome <- scaled_data_added_property_type %>%
  filter(room_type == "Entire home/apt") %>%
  filter(price > 0)

#splitting entirehomes into Manhattan 
scaled_data_added_property_type_entirehome_man <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting entirehomes into Brooklyn
scaled_data_added_property_type_entirehome_brook <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")


#splitting entirehomes into Queens
scaled_data_added_property_type_entirehome_queens <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed =="Queens")



#splitting the rest including Staten Island, Bronx 
scaled_data_added_property_type_entirehome_rest <- scaled_data_added_property_type_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")


scaled_data_added_property_type_hotel <- scaled_data_added_property_type %>%
  filter(room_type == "Hotel room")



scaled_data_added_property_type_private <- scaled_data_added_property_type %>%
  filter(room_type == "Private room") %>%
  filter(reviews_per_month != 'NA') %>%
  filter(price > 0)

#splitting private rooms into Manhattan 
scaled_data_added_property_type_private_man <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")

#splitting private rooms into Brooklyn
scaled_data_added_property_type_private_brook <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn")

#splitting the rest including Staten Island, Bronx and Queens
scaled_data_added_property_type_private_rest <- scaled_data_added_property_type_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")




scaled_data_added_property_type_shared <- scaled_data_added_property_type %>%
  filter(room_type == "Shared room") %>%
  filter(price > 0)



#starting to traing gbm for entirehomes in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_man$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_man_train = scaled_data_added_property_type_entirehome_man[split, ]
scaled_data_added_property_type_entirehome_man_test = scaled_data_added_property_type_entirehome_man[!split, ]


#training gbm for entire homes in manhatten
set.seed(1031)
modelentire_man_gbm <- gbm(price ~ ex + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                             number_of_reviews + review_scores_rating + review_scores_accuracy + review_scores_cleanliness + review_scores_value + reviews_per_month + 
                             cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,                       
                           distribution = "gaussian",
                           data = scaled_data_added_property_type_entirehome_man,
                           n.trees = 3637,
                           interaction.depth = 8,
                           shrinkage = 0.010,
                           n.minobsinnode = 25)

summary(modelentire_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelentire_man_gbm, newdata = scaled_data_added_property_type_entirehome_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_man_test$price - pre

scaled_data_added_property_type_entirehome_man_test_meanprice = mean(scaled_data_added_property_type_entirehome_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_man_test$price - scaled_data_added_property_type_entirehome_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#tuning the best gbm model. Took too long to run

#trControl = trainControl(method="cv",number=5)
#tuneGrid = expand.grid(n.trees = 1000, 
#                       interaction.depth = c(1,2,3),
#                       shrinkage = (1:100)*0.001,
#                       n.minobsinnode=c(5,10,15))
#garbage = capture.output(cvModel <- train(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                            cancellation_policy,
#                                          data = scaled_data_added_property_type_entirehome_man_train,
#                                          method="gbm",
#                                          trControl=trControl, 
#                                          tuneGrid=tuneGrid))

#modelentire_man_gbm_best = gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
#                                 bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
#                                 number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
#                                 cancellation_policy,
#                               data = scaled_data_added_property_type_entirehome_man_train,
#              distribution="gaussian",
#              n.trees=cvModel$bestTune$n.trees,
#              interaction.depth=cvModel$bestTune$interaction.depth,
#              shrinkage=cvModel$bestTune$shrinkage,
#              n.minobsinnode = cvModel$bestTune$n.minobsinnode)

#pred = predict(modelentire_man_gbm_best, newData = scaled_data_added_property_type_entirehome_man_test, n.trees=1000)
#rmse_cv_boost = sqrt(mean((pred-scaled_data_added_property_type_entirehome_man_test$earn)^2))

#rmse_cv_boost


#using lm for entirehome manhattan
modelentirehome_man <- lm(price ~ neighbourhood_cleansed + zipcode + property_type + accommodates *
                            bathrooms * bedrooms + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                            number_of_reviews_ltm + review_scores_rating * review_scores_location *reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                            cancellation_policy,
                          data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man)

pre1111 <- predict(modelentirehome_man, newdata = scaled_data_added_property_type_entirehome_man)
rmse_entire1111 <- sqrt(mean((pre1111-scaled_data_added_property_type_entirehome_man$price)^2))
rmse_entire1111



#using lm for entirehome manhattan (outliers without the same zipcode)
modelentirehome_man_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating + 
                                cancellation_policy,
                              data = scaled_data_added_property_type_entirehome_man)

summary(modelentirehome_man_out)




#starting to traing gbm for entirehomes in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_brook_train = scaled_data_added_property_type_entirehome_brook[split, ]
scaled_data_added_property_type_entirehome_brook_test = scaled_data_added_property_type_entirehome_brook[!split, ]


#training gbm for entire homes in brooklyn
set.seed(1031)
modelentire_brook_gbm <- gbm(price ~ ex + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                               bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                               number_of_reviews_ltm + review_scores_rating + review_scores_location + review_scores_accuracy +reviews_per_month+ review_scores_value +
                               cancellation_policy + calculated_host_listings_count,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_entirehome_brook,
                             n.trees = 1083,
                             interaction.depth = 15,
                             shrinkage = 0.009,
                             n.minobsinnode = 50)


summary(modelentire_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_brook_gbm, newdata = scaled_data_added_property_type_entirehome_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_brook_test$price - pre

scaled_data_added_property_type_entirehome_brook_test_meanprice = mean(scaled_data_added_property_type_entirehome_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_brook_test$price - scaled_data_added_property_type_entirehome_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for entirehome brooklyn
modelentirehome_brook <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                            data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook)

pre1112 <- predict(modelentirehome_brook, newdata = scaled_data_added_property_type_entirehome_brook)
rmse_entire1112 <- sqrt(mean((pre1112-scaled_data_added_property_type_entirehome_brook$price)^2))
rmse_entire1112


#using lm for entirehome brooklyn (outliers that cannot match zipcode)
modelentirehome_brook_out <- lm(price ~ ex + neighbourhood_cleansed + property_type + accommodates *
                                  bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                                  number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating,
                                data = scaled_data_added_property_type_entirehome_brook)

summary(modelentirehome_brook_out)






#starting to traing gbm for entirehomes in queens
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_queens$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_queens_train = scaled_data_added_property_type_entirehome_queens[split, ]
scaled_data_added_property_type_entirehome_queens_test = scaled_data_added_property_type_entirehome_queens[!split, ]


#training gbm for entire homes in queens
set.seed(1031)
modelentire_queens_gbm <- gbm(price ~ ex + host_listings_count + security_deposit + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms  + minimum_nights_avg_ntm + guests_included * extra_people + availability_30 + availability_365 +
                                number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                                cancellation_policy + calculated_host_listings_count + calculated_host_listings_count_entire_homes,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_entirehome_queens,
                              n.trees = 656,
                              interaction.depth = 3,
                              shrinkage = 0.01,
                              n.minobsinnode = 11)

summary(modelentire_queens_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_queens_gbm, newdata = scaled_data_added_property_type_entirehome_queens_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_queens_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_queens_test$price - pre

scaled_data_added_property_type_entirehome_queens_test_meanprice = mean(scaled_data_added_property_type_entirehome_queens_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_queens_test$price - scaled_data_added_property_type_entirehome_queens_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq










#starting to traing gbm for entirehomes in Staten Island and Bronx
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_entirehome_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_entirehome_rest_train = scaled_data_added_property_type_entirehome_rest[split, ]
scaled_data_added_property_type_entirehome_rest_test = scaled_data_added_property_type_entirehome_rest[!split, ]


#training gbm for entire homes in Staten Island and Bronx
set.seed(1031)
modelentire_rest_gbm <- gbm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms  + minimum_nights + guests_included * extra_people + availability_30 + availability_365 +
                              number_of_reviews + review_scores_rating * review_scores_location* reviews_per_month + review_scores_accuracy + review_scores_value  + review_scores_rating +
                              cancellation_policy + calculated_host_listings_count * calculated_host_listings_count_entire_homes,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_entirehome_rest,
                            n.trees = 950,
                            interaction.depth = 8,
                            shrinkage = 0.01,
                            n.minobsinnode = 5)

summary(modelentire_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelentire_rest_gbm, newdata = scaled_data_added_property_type_entirehome_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_entirehome_rest_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_entirehome_rest_test$price - pre

scaled_data_added_property_type_entirehome_rest_test_meanprice = mean(scaled_data_added_property_type_entirehome_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_entirehome_rest_test$price - scaled_data_added_property_type_entirehome_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq







#using lm for entirehome staten island, bronx, queens
modelentirehome_rest <- lm(price ~ ex + neighbourhood_cleansed + zipcode + property_type + accommodates *
                             bathrooms * bedrooms + minimum_nights + availability_30 +
                             review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                           data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest)

pre1113 <- predict(modelentirehome_rest, newdata = scaled_data_added_property_type_entirehome_rest)
rmse_entire1113 <- sqrt(mean((pre1113-scaled_data_added_property_type_entirehome_rest$price)^2))
rmse_entire1113

#using lm for entirehome staten island, bronx, queens (outliers that cannot match zipcode)
modelentirehome_rest_out <- lm(price ~ ex + accommodates *
                                 bathrooms * bedrooms + minimum_nights + availability_30 +
                                 review_scores_rating * review_scores_location * reviews_per_month + review_scores_rating,
                               data = scaled_data_added_property_type_entirehome_rest)

summary(modelentirehome_rest_out)





#starting to traing gbm for private rooms in manhatten
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_man$price,SplitRatio=0.8)
scaled_data_added_property_type_private_man_train = scaled_data_added_property_type_private_man[split, ]
scaled_data_added_property_type_private_man_test = scaled_data_added_property_type_private_man[!split, ]


#training gbm for private in manhatten
set.seed(1031)
modelprivate_man_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                              bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                              number_of_reviews_ltm + review_scores_rating * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                            distribution = "gaussian",
                            data = scaled_data_added_property_type_private_man,
                            n.trees = 1071,
                            interaction.depth = 7,
                            shrinkage = 0.01,
                            n.minobsinnode = 30)

summary(modelprivate_man_gbm)


#predicting the prices for test data based on the gbm model
pre <- predict(modelprivate_man_gbm, newdata = scaled_data_added_property_type_private_man_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_man_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_man_test$price - pre

scaled_data_added_property_type_private_man_test_meanprice = mean(scaled_data_added_property_type_private_man_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_man_test$price - scaled_data_added_property_type_private_man_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq






#starting to traing gbm for private in brooklyn
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_brook$price,SplitRatio=0.8)
scaled_data_added_property_type_private_brook_train = scaled_data_added_property_type_private_brook[split, ]
scaled_data_added_property_type_private_brook_test = scaled_data_added_property_type_private_brook[!split, ]


#training gbm for private in brooklyn
set.seed(1031)
modelprivate_brook_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + property_type + accommodates *
                                bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                                number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count + calculated_host_listings_count_private_rooms,
                              distribution = "gaussian",
                              data = scaled_data_added_property_type_private_brook,
                              n.trees = 850,
                              interaction.depth = 2,
                              shrinkage = 0.01,
                              n.minobsinnode = 50)

summary(modelprivate_brook_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_brook_gbm, newdata = scaled_data_added_property_type_private_brook_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_brook_test$price)^2))
rmse_entire


#finding R-squared value
residuals = scaled_data_added_property_type_private_brook_test$price - pre

scaled_data_added_property_type_private_brook_test_meanprice = mean(scaled_data_added_property_type_private_brook_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_brook_test$price - scaled_data_added_property_type_private_brook_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq








#starting to traing gbm for private in rest of boroughs
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_private_rest$price,SplitRatio=0.8)
scaled_data_added_property_type_private_rest_train = scaled_data_added_property_type_private_rest[split, ]
scaled_data_added_property_type_private_rest_test = scaled_data_added_property_type_private_rest[!split, ]


#training gbm for private in rest
set.seed(1031)
modelprivate_rest_gbm <- gbm(price ~ ex + cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                               bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                               number_of_reviews + review_scores_rating * review_scores_location * reviews_per_month + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                             distribution = "gaussian",
                             data = scaled_data_added_property_type_private_rest,
                             n.trees = 1050,
                             interaction.depth = 2,
                             shrinkage = 0.01,
                             n.minobsinnode = 130)

summary(modelprivate_rest_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelprivate_rest_gbm, newdata = scaled_data_added_property_type_private_rest_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_private_rest_test$price)^2))
rmse_entire



#finding R-squared value
residuals = scaled_data_added_property_type_private_rest_test$price - pre

scaled_data_added_property_type_private_rest_test_meanprice = mean(scaled_data_added_property_type_private_rest_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_private_rest_test$price - scaled_data_added_property_type_private_rest_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq




#model for private
modelprivate <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                     bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                     number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                   data = scaled_data_added_property_type_private)

summary(modelprivate)

pre777 <- predict(modelprivate, newdata = scaled_data_added_property_type_private)
rmse_entire777 <- sqrt(mean((pre777-scaled_data_added_property_type_private$price)^2))
rmse_entire777





#model for private (outliers that cannot match zipcode)
modelprivate_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms * bedrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count * calculated_host_listings_count_private_rooms,
                       data = scaled_data_added_property_type_private)

summary(modelprivate_out)





#starting to traing gbm for shared rooms
#splitting into training and testing
set.seed(1234)

split = sample.split(scaled_data_added_property_type_shared$price,SplitRatio=0.8)
scaled_data_added_property_type_shared_train = scaled_data_added_property_type_shared[split, ]
scaled_data_added_property_type_shared_test = scaled_data_added_property_type_shared[!split, ]


#training gbm for shared
set.seed(1031)
modelshared_gbm <- gbm(price ~ cleaning_fee + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                         bathrooms + guests_included * extra_people + minimum_nights_avg_ntm + availability_30 + availability_365 +
                         number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                       distribution = "gaussian",
                       data = scaled_data_added_property_type_shared,
                       n.trees = 400,
                       interaction.depth = 3,
                       shrinkage = 0.01,
                       n.minobsinnode = 11)

summary(modelshared_gbm)


#predicting the prices based on the gbm model
pre <- predict(modelshared_gbm, newdata = scaled_data_added_property_type_shared_test)
rmse_entire <- sqrt(mean((pre-scaled_data_added_property_type_shared_test$price)^2))
rmse_entire

#finding R-squared value
residuals = scaled_data_added_property_type_shared_test$price - pre

scaled_data_added_property_type_shared_test_meanprice = mean(scaled_data_added_property_type_shared_test$price)

# Calculate total sum of squares
tss =  sum((scaled_data_added_property_type_shared_test$price - scaled_data_added_property_type_shared_test_meanprice)^2 )

# Calculate residual sum of squares
rss =  sum(residuals^2)

# Calculate R-squared value
rsq  =  1 - (rss/tss)
rsq





#using lm for shared
modelshared <- lm(price ~ ex + neighbourhood_cleansed + zipcode + neighbourhood_group_cleansed + property_type + accommodates *
                    bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                    number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                  data = scaled_data_added_property_type_shared)

summary(modelshared)

pre888 <- predict(modelshared, newdata = scaled_data_added_property_type_shared)
rmse_entire888 <- sqrt(mean((pre888-scaled_data_added_property_type_shared$price)^2))
rmse_entire888

#using lm for shared (outliers that cannot match zipcode)
modelshared_out <- lm(price ~ ex + neighbourhood_group_cleansed + property_type + accommodates *
                        bathrooms + guests_included * extra_people + minimum_nights + availability_30 + availability_365 +
                        number_of_reviews_ltm + review_scores_rating * review_scores_location * reviews_per_month + review_scores_value + calculated_host_listings_count_shared_rooms,
                      data = scaled_data_added_property_type_shared)

summary(modelshared_out)





#standardizing the numerical variables for testing data
scaled_scoringData  <- scoringData %>%
  mutate_at(c("accommodates", "bathrooms", "bedrooms", "guests_included", "extra_people", "minimum_nights", "maximum_minimum_nights", "minimum_maximum_nights", "maximum_maximum_nights", "maximum_nights_avg_ntm",
              "availability_30", "availability_365", "number_of_reviews_ltm", "review_scores_rating", "review_scores_checkin", "review_scores_communication", "review_scores_location", "reviews_per_month", "review_scores_cleanliness",
              "review_scores_value", "calculated_host_listings_count", "calculated_host_listings_count_entire_homes",
              "host_listings_count", "calculated_host_listings_count_private_rooms", "calculated_host_listings_count_shared_rooms", "review_scores_accuracy", "cleaning_fee", "security_deposit"),
            ~(scale(.) %>% as.vector))
scaled_scoringData


scaled_scoringData$cleaning_fee[is.na(scaled_scoringData$cleaning_fee)] <- 0
scaled_scoringData$security_deposit[is.na(scaled_scoringData$security_deposit)] <- 0




scaled_scoringData$zipcode <- as.factor(scaled_scoringData$zipcode)
scaled_scoringData$neighbourhood_group_cleansed <- as.factor(scaled_scoringData$neighbourhood_group_cleansed)
scaled_scoringData$neighbourhood_cleansed <- as.factor(scaled_scoringData$neighbourhood_cleansed)
scaled_scoringData$cancellation_policy <- as.factor(scaled_scoringData$cancellation_policy)
scaled_scoringData$property_type <- as.factor(scaled_scoringData$property_type)








words <- c("luxury","Luxury", "Penthouse", "LUXURY", "LUX", "Townhome", "Beekman Tower",
           "Presidential", "Upscale", "PRESIDENTIAL","Luxurious", "SoHo", "soho", "Soho",
           "Townhouse", "townhouse")
scaled_scoringData2 <- scaled_scoringData
ex <- scaled_scoringData2[rowSums(sapply(words, grepl, scaled_scoringData2$name)) > 0, , drop = FALSE]
ex

index = as.list(ex$id)

scaled_scoringData2_ex<- scaled_scoringData2[scaled_scoringData2$id %in% index, ]
scaled_scoringData2_not_ex<- scaled_scoringData2[!scaled_scoringData2$id %in% index, ]

scaled_scoringData2_ex$ex = 1
scaled_scoringData2_not_ex$ex = 0

scaled_scoringData2 <- rbind(scaled_scoringData2_ex,
                             scaled_scoringData2_not_ex)

scaled_scoringData2 <- scaled_scoringData2[order(scaled_scoringData2$id, decreasing = FALSE), ]

scaled_scoringData <- scaled_scoringData2





scaled_scoringData_entirehome <- scaled_scoringData %>%
  filter(room_type == "Entire home/apt")

#splitting entirehomes into Manhattan 
scaled_scoringData_entirehome_man <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting entirehomes into Brooklyn
scaled_scoringData_entirehome_brook <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting entirehomes into queens
scaled_scoringData_entirehome_queens <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Queens") 


#splitting the rest including Staten Island, Bronx 
scaled_scoringData_entirehome_rest <- scaled_scoringData_entirehome %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx")



scaled_scoringData_hotel <- scaled_scoringData %>%
  filter(room_type == "Hotel room")



scaled_scoringData_private <- scaled_scoringData %>%
  filter(room_type == "Private room")

#splitting private into Manhattan 
scaled_scoringData_private_man <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Manhattan")


#splitting private into Brooklyn
scaled_scoringData_private_brook <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Brooklyn") 


#splitting the rest including Staten Island, Bronx and Queens
scaled_scoringData_private_rest <- scaled_scoringData_private %>%
  filter(neighbourhood_group_cleansed == "Staten Island" | neighbourhood_group_cleansed == "Bronx" | neighbourhood_group_cleansed =="Queens")





#shared rooms
scaled_scoringData_shared <- scaled_scoringData %>%
  filter(room_type == "Shared room")



pred_entirehome_man <- predict(modelentire_man_gbm, newdata = scaled_scoringData_entirehome_man)

pred_entirehome_brook <- predict(modelentire_brook_gbm, newdata = scaled_scoringData_entirehome_brook)

pred_entirehome_queens <- predict(modelentire_queens_gbm, newdata = scaled_scoringData_entirehome_queens)

pred_entirehome_rest <- predict(modelentire_rest_gbm, newdata = scaled_scoringData_entirehome_rest)


pred_hotel <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_hotel)

pred_private_man <- predict(modelprivate_man_gbm, newdata = scaled_scoringData_private_man)

pred_private_brook <- predict(modelprivate_brook_gbm, newdata = scaled_scoringData_private_brook)

pred_private_rest <- predict(modelprivate_rest_gbm, newdata = scaled_scoringData_private_rest)


pred_shared <- predict(modelshared_gbm, newdata = scaled_scoringData_shared)





scaled_scoringData_entirehome_man$price <- pred_entirehome_man

scaled_scoringData_entirehome_brook$price <- pred_entirehome_brook

scaled_scoringData_entirehome_queens$price <- pred_entirehome_queens

scaled_scoringData_entirehome_rest$price <- pred_entirehome_rest


scaled_scoringData_hotel$price <- pred_hotel

scaled_scoringData_private_man$price <- pred_private_man

scaled_scoringData_private_brook$price <- pred_private_brook

scaled_scoringData_private_rest$price <- pred_private_rest

scaled_scoringData_shared$price <- pred_shared



scaled_scoringData_entirehome_man_id_price <- scaled_scoringData_entirehome_man [, c(1,92)]

scaled_scoringData_entirehome_brook_id_price <- scaled_scoringData_entirehome_brook [, c(1,92)]

scaled_scoringData_entirehome_queens_id_price <- scaled_scoringData_entirehome_queens [, c(1,92)]

scaled_scoringData_entirehome_rest_id_price <- scaled_scoringData_entirehome_rest [, c(1,92)]


scaled_scoringData_hotel_id_price <- scaled_scoringData_hotel [, c(1,92)]

scaled_scoringData_private_man_id_price <- scaled_scoringData_private_man [, c(1,92)]

scaled_scoringData_private_brook_id_price <- scaled_scoringData_private_brook [, c(1,92)]

scaled_scoringData_private_rest_id_price <- scaled_scoringData_private_rest [, c(1,92)]

scaled_scoringData_shared_id_price <- scaled_scoringData_shared [, c(1,92)]



scaled_scoringData_price <- rbind(scaled_scoringData_entirehome_man_id_price,
                                  scaled_scoringData_entirehome_brook_id_price,
                                  scaled_scoringData_entirehome_queens_id_price,
                                  scaled_scoringData_entirehome_rest_id_price,
                                  scaled_scoringData_hotel_id_price,
                                  scaled_scoringData_private_man_id_price,
                                  scaled_scoringData_private_brook_id_price,
                                  scaled_scoringData_private_rest_id_price,
                                  scaled_scoringData_shared_id_price)


#replacing all negative predicted price and small values to default $0
scaled_scoringData_price_negative <- scaled_scoringData_price %>%
  filter(price <= 0) %>%
  mutate (price = 0)

#keeping the rest of predicted price
scaled_scoringData_price_remaining <- scaled_scoringData_price %>%
  filter(price > 0)

scaled_scoringData_price <- rbind(scaled_scoringData_price_remaining,
                                  scaled_scoringData_price_negative)

scaled_scoringData_price_ordered <- scaled_scoringData_price[order(scaled_scoringData_price$id, decreasing = FALSE), ]

#Construct submission from prediction
submissionFile = data.frame(id = scaled_scoringData_price_ordered$id, price = scaled_scoringData_price_ordered$price)
write.csv(submissionFile, 'submission_70_le_wei_boon.csv', row.names = F)
